巫银良-SAS 公司技术总监，公众号: PowerToKnow

从程序员到数据科学家：SAS 编程基础 （1-8）http://igeekbar.com/igeekbar/mypost/110.htm

从程序员到数据科学家：SAS 编程基础 （9）- 数组 http://www.sohu.com/a/129320433_278472

从程序员到数据科学家：SAS 编程基础 （10）- 流程控制 http://www.sohu.com/a/129661394_649951

从程序员到数据科学家：SAS 编程基础 （12）- SAS 宏（上）http://www.sohu.com/a/137166217_278472



目录Table of Contents:

[TOC]



## 01 - 入门

SAS是英文Statistical Analysis System 的简称。首先SAS作为一家企业，它是一家由 James Goodnight和 John Sall 成立于1976年，总部位于美国北卡罗来纳州的长青藤软件公司。SAS是全球商业分析软件和服务的领导者，商业智能行业的最大独立供应商。

 

SAS 作为一种软件系统，它以提供“知的力量”（The Power to Know®）为己任，向全球各行各业提供全面的数据分析软件技术，包括统计分析、趋势预报、预测模型和优化。

 

SAS 作为一种计算机语言，是专门为数据处理和统计分析而设计的第四代计算机编程语言，主要面向数据操作，分析和报告。SAS自成立40多年来一直在帮助用户将各种数据转化为知识与智慧，发掘企业数据的商业价值。

 

在开始学习SAS编程之前，有必要了解一下**SAS 计算服务的三大核心模块：SAS 语言，SAS 引擎，数据库服务**



#### - SAS 语言

用于编写SAS 程序，主要由一系列面向数据操作和分析的代码构成，语言元素主要包括：

1)   SAS 宏（SAS **Macro**）：包括宏变量和宏函数，实现SAS代码重用，减少重复代码。

2)  数据步（**DATA** Step）：负责数据读入，数据处理并创建SAS 能理解的数据表示（数据集和数据列）。

3)  过程步（**PROC** Step）：负责对数据进行分析，完成各种统计功能和图表功能等。

 

SAS 语言是跨平台的编程语言，编写好的SAS 程序可以运行在各种主机架构的Linux、Unix、Windows、甚至IBM 大型主机上。SAS 运行环境就像JVM或CLR环境，提供平台无关的执行环境；某种意义上，SAS 公司比Java还早（1985-1989）提出革命性的“主机无关的可移植层”概念，并在其SAS运行环境（内部称为MVA架构：Multi-Vendor Architecture）使用至今。

 

SAS运行环境包括一个称为输出传送系统（Output Delivery System，简称**ODS**）的部分，用于管理SAS 程序的输出（有点类似其他编程语言的I/O），ODS支持三种SAS格式的目标（LISTING, OUTPUT，DOCUMEN）和多种第三方格式目标（HTML，PRINTER，MARKUP，RTF），用户也可以自定义模板输出，控制分析结果的形态。

 

#### - SAS引擎

SAS 库引擎（SAS Library Engines）和远程库服务（Remote Library Services）让用户在SAS 代码中可以非常方便地访问外部数据结构、或存储于远程计算机平台（比如各种数据库）的数据。SAS 引擎可以在不同的 SAS 服务器中工作：

1)         工作区服务器（Workspace Server）：SAS 代码每次提交本服务器运行，都会新建一个SAS 运行环境（对应操作系统的一个进程），称为SAS会话。

2)         存储过程服务器（Stored Process Server）：SAS 代码每次提交本服务器运行，会共享SAS作为服务启动时建立的那个SAS会话。

3)         连接服务器（SAS/Connect Server）：可以让客户端机器在服务端机器上充分利用资源运行 SAS 程序处理结果，构建“SAS到SAS”的客户端/服务区环境。

4)         网格服务器（Grid Server）：SAS应用服务器上用于桥接SAS 应用和SAS网格环境的逻辑服务器，实现将繁重的计算作业分配到网格环境上进行并行执行。

 

SAS 引擎对用户而言屏蔽了数据访问和执行环境的细节，让用户通过SAS 库（SAS Library）引用需要分析的数据而无需关注存储格式和数据库类型，以及计算资源的形态。因此，SAS 分析代码可以变得非常清晰可重用。

 

#### - 数据库服务

1)   数据访问（Data Access）：对于各种各样的数据存在形态和数据库，SAS都提供对应的数据访问服务来保证对特定数据的访问，SAS支持从PC文件到关系型数据库、从分布式文件系统HDFS到云端的数据访问。

2)   库内处理（In-Database Processing）：SAS为改进系统性能，减少数据在数据库和SAS 之间的移动，加速分析的开发和部署而设计的一种高性能分析平台技术；它采用更加智能化的SQL来增强所选的分析过程，在一些关键用例上将SAS 函数直接部署到数据库内部。

3)   内存分析（SAS® In-Memory Analytics）：随着大数据时代的到来，高级分析和可视化分析呼唤对海量数据的大规模并发访问。SAS运行在分布式计算环境（而不是单个机器）的LASR 分析服务器（LASR® Analytics Server）能够预先将海量数据加载到内存中，提供安全，无状态的只读操作，从而实现对海量数据的分析在秒级完成。2016年，SAS再次创新性地推出了SAS 云分析服务（简称：CAS - Cloud Analytics Services）， CAS是可以SAS运行在云端的、最新的数据管理和分析运行环境，它可以直接对存储在云端（比如亚马逊云）的数据进行能够分析处理。

 4）SAS网格计算（SAS® Grid Computing）、库内计算（SAS® In-Database）和内存计算（SAS® In-Memory Analytics）是SAS高性能分析平台传统上的三大支柱；近40年来，不管计算环境如何变化，SAS一直致力于将最好的分析技术带给用户，为客户提供从数据、信息到知识、乃至智能的“知的力量——The Power To Know™”。

 有了以上这些基础，就让我们以最简单的SAS程序Hello World结束本章，在下一章开始我们的SAS 编程之旅！ 

```
data _null_;
    put "THE POWER TO KNOW";
    put "-- Since 1976 --";
run;
```



## 02 - 语法

[TIOBE](http://www.tiobe.com/tiobe-index) 指数是用来反映某种编程语言的流程程度的指标，根据2016年12月份最新数据显示，SAS 编程语言占比 1.380%，排名22位。 编程语言本质上是人类用来与机器沟通，并在人类之间分享思维的工具，与它所需要解决的问题领域紧密相关。世界上也没有哪一种语言能够解决所有问题。所以尽管计算机领域出现了超过上千种编程语言，但终究只有少数强大语言能生存下来，SAS 便是其中之一。

 SAS 语言要入门很快，但要精通则需要较长时间，尤其是要掌握SAS特有的，在普通编程语言里面没有的一些功能。SAS 作为领域特定的第四代编程语言（[4GL](https://en.wikipedia.org/wiki/Fourth-generation_programming_language)），与广泛流行的第三代编程语言C，C++，Java，C#，Javascript不同，它专门为数据分析和报告提供非常复杂的数据操作、图形图表制作以及文档编写功能。

 SAS语言总体上是面向过程的计算机语言，有着传统编程语言的基本结构。但它不支持面向对象，尽管从SAS 9 开始提供两个预定义的对象：Hash和 HIter（Hash Iterator）并提供类似面向对象的语法，但用户至今不能用 SAS 语言创建自定义类。SAS提供强大的互操作能力，可以调用Java 对象和 Win32 API 函数来实现各种复杂功能。SAS 语言也并不像Python/Perl等严格意义上的脚本式编程语言，具有真正的脚本/流控制构造。

 

SAS 语言中只有两种基本的数据类型：***字符型和数值型***。从外部数据到SAS内部数据存储表达之间，可以使用***INFORMAT和 FORMAT***进行读／写转换。然而，在一些 PROC 步中，SAS 也提供特定的数据类型来覆盖这两种基本类型，比如PROC FCMP（从 SAS 9.1开始）中类似Ｃ语言的结构体，以及PROC IML 中的矩阵。与传统编程语言支持各种各样的基本数据类型（比如布尔/整数/浮点/字符…）不同，***统计学上的数据类型根据计量尺度只有定类（如性别）、定序（如年级）、定距（如温度）以及定比（重量）等四种需要考虑***。

 

SAS 语言提供非常强大预处理器，实现编译前的宏替换功能。它允许 SAS 程序在编译和运行期间，动态改变程序自身，并可实现递归调用宏本身。使用 SAS 语言的统计分析人员经常赞叹SAS语言的强大功能，而不熟悉 SAS 语言的编程人员有时也会为它与第三代编程语言的不同而困惑不解，迷失在宏与非宏的代码陷阱里。

 

SAS 语言是一门比较复杂的计算机语言，甚至它到底是编译执行还是解释执行有时候连有经验的SAS开发人员也会感到困惑。由于SAS 语言包含灵活的语言元素，SAS Macro宏是由解释器展开，但是 DATA Step和 Proc Step 则以步为单位进行一次编译，然后统一执行而非逐语句进行解释执行。SAS是兼具编译和解释的混合型计算机语言，因此维基百科的分类中也很难将SAS 语言归入编译还是解释类别（[Compiled_language](https://en.wikipedia.org/wiki/Compiled_language) v.s [Interpreted_language](https://en.wikipedia.org/wiki/Interpreted_language)）。

 

SAS 语言最强大的能力是为分析编程人员提供了完备细致的数据访问，而不用太考虑数据的存储格式和存储位置，比如最常用的DATA Step和 PROC SQL就提供了各种各样的数据操作能力，而丰富的 PROC Step 支持则让分析人员专注于分析本身和参数设定。一旦 SAS 编程入门，则只有不懂的统计类型，没有不会使用的 PROC Step。

 

从传统语言编程基础转换到SAS 语言编程，首先要记得如下一些SAS语言的核心规则：

- SAS 程序由一系列SAS 语句组成，所有的语句都以分号 ; 结束。

-  SAS 代码中也可以包含数据行，但数据行不作为语句，不以分号结尾。

-  一个SAS语句可以跨行，多个 SAS 语句也可以在一行上；SAS 语句可以从一行中的任意位置开始，代码缩进并非必需。

- SAS 语句中的关键字是以空格分隔的，通常由“关键字”或“关键字=参数”系列组成；某些语句可以在必选项和可选项之间用 / 分隔。

- SAS 语言不区分大小写，你可以使用大写/小写以及它们的混合。但字符变量的值是区分大小写的。比如 “Hello World” 和 “HELLO WORLD” 为不同的两个值。

- SAS 代码中标识符长度较短：逻辑库引用/文件引用（libref/fileref）名称最长不超过8字节、数据表/数据列（即变量）名称最多不超过32字节。 

  

SAS 程序主要由一系列的 Steps 构成，而 Step 由一些列的 Statements  构成。每一个 Step 都有开始和结束的边界，SAS 根据 Step 边界独立编译和执行。 

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/4f105107-78f9-43f2-a4c4-ec27a0a022ee.png)](http://igeekbar.com/igeekbar/networks/uploadimg/4f105107-78f9-43f2-a4c4-ec27a0a022ee.png)

 

一个所谓的步（Step）由 DATA或PROC 语句开始，默认结束于下一个 DATA/PROC 步的开始处。但我们通常用 RUN; 语句来显式结束一个 Step．有一些 PROC需要以 QUIT 语句来结束提交。为了让代码具有良好的可读性，通常使用 RUN/QUIT来显式结束一个步。 



#### - 全局语句

在 DATA/PROC 步之外，用于指定全局的选项或者其他全局性的功能



比如 TITLE 语句用来指定输出报告的标题，最多达11级。 

```
TITLE "The title of my first report"; /*设置输出报告的标题*/
TITLE2 "Author: Yinliang Wu";  
 
```

各种SAS 选项（SAS Options）语句也属于全局语句，功能上类似于操作系统的环境变量，用来指定当前 SAS会话有关的系统设置。

```
options ls=80 ps=24 nocenter; /*设置输出为 24 X 80 左对齐*/
 
```



#### - DATA 步（Data Step）

SAS 程序只包含两种类型的步DATA步和PROC步，DATA 步负责为后续数据步/过程步准备数据，基本语法为： 

```
DATA MYDATA; 
 
<STATEMENT and/or DATA>;
RUN;
```

 比如：如下代码创建一行5列的数据，其中 Name和Sex 是字符变量，而其他3个为数值变量。 

```
DATA MyData; 
  input Name $ Sex $ Age Height Weight;
  datalines;
YINLIANG M 30 175 83.5 
RUN;
```



#### - PROC 步（PROC Step）

过程步是执行特定任务的SAS语句 的集合，以 PROC 语句开始，一般到下一个 RUN语句结束；某些PROC（如PROC SQL）允许有多条RUN语句进行执行，但该PROC仅在最后一个QUIT语句运行后结束。 每个过程步有自己特定的SAS 语句和命令，但也有很多过程步有相同的SAS 语句和命令。 

```
PROC PRINT DATA=MyData;
    VAR Name Height;
RUN;
```

```
PROC CONTENTS DATA=MyData;
RUN;
```

DATA=MyData是**PROC PRINT** 和 **PROC CONTENTS** 语句特定的参数（也叫选项），所有的PROC步都有 DATA= 选项。如果没有指定，则系统默认为执行过程中最近创建的那个数据集。

 

#### - 程序注释

a)         块注释：SAS 支持C、C++和 Java 等广泛使用的块注释 /* …注释… */ 功能，注释可以是任何长度，可包括分号但不能嵌套使用块注释；

```
/* …
 *
…注释…;
 *
…
 */
PROC CONTENTS DATA=MyData;
RUN;
```

b)         **行注释**：以星号 * 开始，以往后的第一个分号 ; 结束。比如：

```
* …注释…;
PROC CONTENTS DATA=MyData;
* …注释…;
  * …注释…;
RUN;
```

注释通常用于说明程序的功能、标注非执行文本或者用于文档目的，可以在代码调试过程中将调好的代码暂时隔离。SAS 运行时注释中的代码会被忽略，但注释也会被写入日志文件。 需要特别注意的一点是，在SAS Macro 宏代码要谨慎使用行注释，以免导致不期望的宏展开。

结语： SAS 的 DATA 步和PROC 步是SAS 语言对数据分析工作的精妙抽象和完美封装，DATA 步解决数据结构和准备问题，而PROC步解决对特定分析流程的实现和封装。你可以把它对应成传统编程中的数据结构和算法设计，分别负责数据和逻辑的实现。





## 03 - 编程环境

SAS 编程需要使用什么样的开发环境？其实，跟任何恰计算机语言一样，你可以用任何纯文本编辑器编写 SAS 代码，比如 Windows 平台的记事本，NotePad++，你也可以使用 Unix 上的vi 来编辑代码。不过需要注意的是，Windows 上使用回车换行 CRLF而 Unix 使用 LF 来换行。

 

如果你要运行调试 SAS 代码，则需要安装SAS运行环境**SAS Foundation**；你也可以安装更加高级的 Windows 桌面客户端 **SAS Enterprise Guide**，或者使用Web 客户端 **SAS Studio**来远程提交执行代码。

 

不管哪一种窗口界面，安装完毕后大体都会有三个窗口：编写／提交 SAS 代码的 **[编辑]** 窗口，查看SAS 代码运行细节的 **[日志]** 窗口，显示输出结果的 **[输出]**窗口。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/fe5d6a77-7d3f-46f2-9a06-eb49294f5b14.png)](http://igeekbar.com/igeekbar/networks/uploadimg/fe5d6a77-7d3f-46f2-9a06-eb49294f5b14.png)

在代码窗口中输入如下代码，然后点击菜单 **运行(R)-提交(S)** 或者直接点击工具然上面的运行按钮，就可以在日志窗口中看到提交代码的细节和执行结果：在日志窗口中输出Hello World! 

```
Data _null_;
    put "Hello World!";
run;
```

 在SAS 代码提交编译运行时，SAS 会检查语法错误，并将语法错误输出到日志窗口中。语句中常见的语法错误包括的**关键字拼写错误**，**无效选项**，**引号不匹配**，或者**语句结束符分号缺失**等。

语法错误信息包括出错的行列，以及错误的详细描述，显示在Log窗口中。语法错误包括**ERROR和WARNING**两大类，分别以**红色和绿色**显示。由于SAS具有强大的拼写错误容错能力，SAS能够智能修正的错误被归入WARNNING类错误，代码依然能正常运行。而**红色表示SAS 未能修正的错误，用户必须修正后才能正常执行**。比如： 

```
procx printx datax=sashelp.class;
run;
```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/1e87540e-885f-48fd-ae57-fc88238ed8cc.png)](http://igeekbar.com/igeekbar/networks/uploadimg/1e87540e-885f-48fd-ae57-fc88238ed8cc.png)

 但对于一些参数错误，比如指定了不存在的数据集 sashelp.classx，SAS会以 ERROR显示。

```
59   proc
print data=sashelp.classx;
ERROR: 文件“SASHELP.CLASSX.DATA”不存在。
60   run;
```

 注意：有时正是因为 SAS 运行环境对代码的容错能力太强，有些错误会隐藏得较深，并不能立马发现。**我们可以采用分块调试的办法将语法错误限制在最小的范围内**。比如：title "Hello World; SAS 只在第三次提交的时候才会报告错误。

 SAS 程序编译之后，SAS扫描整个步骤，在到达 Step边界时如果没有语法错误则执行该步骤，直到整个SAS程序被处理完毕。 

当代码编辑窗口激活时，你可以随时点击菜单 **文件-保存** 来保存您的代码。代码缺省以对应语言的编码（比如 中文是 Simplified Chinese (EUC) ）来保存。你也可以在保存代码对话框中指定Unicode UTF-8, UTF-16LE或 UTF-16BE编码格式，有/或者没有字节顺序标记的方式存储SAS 程序。

 小知识：字节顺序标记BOM就是告诉文件读/写程序在文件最开始的2或3字节处有特殊值：EF BB BF，FF FE，FE FF 分别表示UTF-8，UTF-16 Little Endian和 UTF-16 Big Endian。

 你可能有疑问，为什么输出窗口竟然没有任何输出。与我们传统编程的I/O不同，**SAS 的输出窗口是给前面提到的SAS输出传送系统ODS的LISTING 目标用的**。上面的代码中没有任何ODS 输出，自然输出窗口中没有结果。让我们尝试创建一个数据，然后将数据打印到该窗口中： 

```
/* InsideSAS 
 * Ex1: output to ODS LISTING;
 */
data mydata;
    Name="Yinliang";
    Sex='M';
    Age=30;
    Height=175;
    Weight=83.5;
run;
 
ods _all_ close; *Close
all ODS Destination;
ods listing; *Open Listing Destination;
 
proc print data=mydata;
run;
```

 提交代码执行后，输出窗口会打印用户创建的数据集 work.mydata, Work 是当用户没有显式指定时，SAS 运行时默认的 SAS 工作库。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/5d550581-3722-40ab-8925-5a5a3899296c.png)](http://igeekbar.com/igeekbar/networks/uploadimg/5d550581-3722-40ab-8925-5a5a3899296c.png)

在输出窗口，SAS 会打印出用户新创建的数据集 WORK.MyData

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/a9fefc5c-48a5-4010-bc1e-90ad3b5a6ab7.png)](http://igeekbar.com/igeekbar/networks/uploadimg/a9fefc5c-48a5-4010-bc1e-90ad3b5a6ab7.png)

 如果需要查看SAS 数据集的数据结构和定义，可以使用 PROC CONTENTS.比如： 

```
proc contents data=mydata;
run;
```

 执行结果将显示在输出窗口中。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/8eae0c90-ea3a-4990-98f1-a31bc7cf8fe0.png)](http://igeekbar.com/igeekbar/networks/uploadimg/8eae0c90-ea3a-4990-98f1-a31bc7cf8fe0.png)







## 04 - 编程环境（SODA增补）

本文是**《从程序员到数据科学家：SAS 编程基础-（03）编程环境》的增补篇**，用于专门介绍如何让没有安装 SAS 环境的程序员们，**随时随地免费**使用部署在 **SAS 私有云上的SAS Studio开发环境**！由于主题是面向 SAS Studio 入门，文中部分地方可能使用了前面尚未介绍的SAS代码和有关内容。

 

由于SAS软件本身具有巨大的商业价值，一般的人很难获得最新的安装拷贝。那我们该如何学习SAS编程呢？ SAS 考虑全球不断增长的分析产业人员需求，推出了基于SAS 私有云的SAS Studio 应用服务 SODA。

 

SODA 全称**SAS® OnDemand for Academics**是 SAS 为**学术群体**提供的**免费在线的应用服务环境。**运行在SODA上的SAS Studio可以让您在任何地方任何时间、任何地点编写/运行您的SAS代码。所有数据和代码都会存储在SAS私有云！这是目前学习使用SAS程序开发**成本最低**、**最快捷**的方法——除非你在本地已经安装强大的SAS开发环境。

 

下面就让我们带上一个电子邮箱帐号+网页浏览器一起出发吧…

1.    **【注册用户】：**在浏览器中输入网址：<https://odamid.oda.sas.com/SASODARegistration> ，提交用户名来注册SAS® OnDemand for Academics （SODA）账号，你的邮箱将会收到用户ID，该用户ID会在后面用来登陆 **SODA** **控制中心**，使用SODA提供的应用服务。 

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/9601b661-5353-47da-a7d1-0a711ee9460f.png)](http://igeekbar.com/igeekbar/networks/uploadimg/9601b661-5353-47da-a7d1-0a711ee9460f.png)

2. **【登录云端】**：注册完成后，通过网址[https://odamid.oda.sas.com](https://odamid.oda.sas.com/) 访问SODA控制中心。此时需要您的【用户ID】和【用户密码】。注意：这儿的【用户ID】 并非你的邮箱地址，而是SODA给你分配的用户ID (比如 yinliangwu0)。其界面如下：

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/0e5fff5a-505d-4c5f-9f41-fa03b5c3b0e9.png)](http://igeekbar.com/igeekbar/networks/uploadimg/0e5fff5a-505d-4c5f-9f41-fa03b5c3b0e9.png)

 登录完毕后，系统将引导你到SAS ODA 的控制中心。页面上你将会看到一个 *SAS® Studio* 应用。点击它登录应用即可。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/311d4e7e-f7b0-4849-8c88-de43dcf75a2c.png)](http://igeekbar.com/igeekbar/networks/uploadimg/311d4e7e-f7b0-4849-8c88-de43dcf75a2c.png)

 

你也可以登录 SAS ODA 控制中心后直接在浏览器中输入如下网址访问 SAS Studio <https://odamid.oda.sas.com/SASStudio>。目前SODA提供服务的SAS Studio 为3.5 企业版，支持Chrome27+，IE9-11, Firefox 21+ 和 Apple Safari 6.0+ 以上的浏览器。后台SAS为Linux 64位版本。SAS Studio 为用户提供一个编写/执行SAS程序、简便高效的Web开发环境。



3.       **【开发程序】**登录SAS Studio后，其主界面包括上面的菜单栏、左侧的导航面板和右侧的内容窗口，导航面板“服务器文件和文件夹”、“任务和实用程序”、“代码段”、“逻辑库”、“文件快捷方式” 和 “SAS文件夹” 等内容。其中“服务器文件和文件夹”和“逻辑库” 比较常用。服务器文件和文件夹是你在服务器上的磁盘空间，一般映射到你的主目录 /home/<userid> 上。

 

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/bffe92ab-3a3f-4fd8-a848-366d0c5681d8.png)](http://igeekbar.com/igeekbar/networks/uploadimg/bffe92ab-3a3f-4fd8-a848-366d0c5681d8.png)

 右侧提供了程序窗口，包括 “**代码**”，“**日志**“ 和 “**结果**” 三个窗口。一般步骤是在代码窗口中输入SAS程序，然后点击代码页签工具栏最左边的**运行按钮**、或者直接按键盘上**F3**功能键直接执行代码。比如：

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/a62170df-eb1e-47bd-998f-6b1ae0ed3493.png)](http://igeekbar.com/igeekbar/networks/uploadimg/a62170df-eb1e-47bd-998f-6b1ae0ed3493.png)

执行结果可以**查看日志窗口**，比如：

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/400a909e-73bc-4375-ace8-f38693148089.png)](http://igeekbar.com/igeekbar/networks/uploadimg/400a909e-73bc-4375-ace8-f38693148089.png)

 **结果窗口**是用来输出 ODS 结果的，我们可以在程序中输入如下代码，然后按 F3 运行SAS代码即可看到有ODS输出结果的情形。

 ```
proc print data=sashelp.class;
run;
 ```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/92f15c2b-0c61-4ec4-a58f-1af9afd7cdda.png)](http://igeekbar.com/igeekbar/networks/uploadimg/92f15c2b-0c61-4ec4-a58f-1af9afd7cdda.png)

在分析中你可能需要上传自己的数据文件，你可以右键点击左侧导航面板中的 “**文件（主目录）**”，然后在菜单中选择 **上载文件**

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/db549886-cd73-4f9c-b2de-c6655c4068d1.png)](http://igeekbar.com/igeekbar/networks/uploadimg/db549886-cd73-4f9c-b2de-c6655c4068d1.png)

 在如下弹出对话框中选择 “选择文件”，然后选择你本地电脑上的数据文件，比如c:\temp\class.csv ，即可将文件上传到您的服务器上。 

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/42ce391f-9579-4017-8275-51b37b740035.png)](http://igeekbar.com/igeekbar/networks/uploadimg/42ce391f-9579-4017-8275-51b37b740035.png)

 *上传完毕在左侧的导航面板“**文件（主目录）**”中将出现 class.csv 文件，表明该文件已经传到云端。如果要将该csv数据导入到SAS 系统中，我们可以**双击它，SAS Studio会自动给您生成对应的SAS Code来导入数据**。你也可以选择不同的参数来进行数据导入。*

 

注意，云端的SAS环境为了给全球所有的用户使用，为支持所有语言和地区的用户，默认的数据文件编码是UTF-8**。而我们**中文Windows环境上生成的中文数据默认是GB2312编码，我们可以使用记事本另存为，选择UTF-8编码的方式来完成转码。

比如，如果我们上传一个本地 Windows 导出的csv文件，而在SAS导入的时候会默认为我们上传的是 UTF-8 格式的文件，此时就会出现乱码的情况。解决方法是：a) 我们手工用记事本或其他工具将数据文件转码；b）我们明确告诉SAS我们的数据文件的编码是 GB2312。导入到运行在云端的SAS内部后，所有的数据集默认都是 UTF-8 编码的。

 如果我们是 Windows 导出的 csv 文件，需要指定数据源文件是 gb2312。如下步骤：

双击class.csv，然后在右侧class 页签下点击 “**编辑**”，SAS Studio会自动给你生成新的SAS代码 “程序2”。运行即可正确导入数据。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/1fdd20d3-b462-401d-989b-6b0268b07110.png)](http://igeekbar.com/igeekbar/networks/uploadimg/1fdd20d3-b462-401d-989b-6b0268b07110.png)

 [![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/03e1c404-d33d-4c1f-8727-d9620e226ff9.png)](http://igeekbar.com/igeekbar/networks/uploadimg/03e1c404-d33d-4c1f-8727-d9620e226ff9.png)

在结果窗口中可以看到导入完毕的数据，比如数据集名称 WORK.IMPORT1。缺省情况下输出数据都会放在临时逻辑库 WORK 中。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/7399bb40-f72d-4a0f-8ea1-9e669f1d4327.png)](http://igeekbar.com/igeekbar/networks/uploadimg/7399bb40-f72d-4a0f-8ea1-9e669f1d4327.png)

 [![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/46149d63-0766-40c4-8be7-1a25dd59a110.png)](http://igeekbar.com/igeekbar/networks/uploadimg/46149d63-0766-40c4-8be7-1a25dd59a110.png)

我们可以通过鼠标右键点击左侧导航栏下的“逻辑库/我的逻辑库/WORK/IMPORT1” 来重命名数据集，比如改为 WORK.CLASS。[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/9f1815e9-13f4-4728-a47f-d6880c25339a.png)](http://igeekbar.com/igeekbar/networks/uploadimg/9f1815e9-13f4-4728-a47f-d6880c25339a.png)

这样，我们就可以在本次SAS会话期间（即本次登录 SAS Studio 期间）一直使用WORK.CLASS数据集。修改代码为如下：

```
proc print data=work.class;
run;
```

运行代码我们将看到打印的数据变为我们刚上传、然后导入的那个数据集 WORK.CLASS. 

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/226c6d2e-e405-48dd-8f8c-ee31a8e0cd2c.png)](http://igeekbar.com/igeekbar/networks/uploadimg/226c6d2e-e405-48dd-8f8c-ee31a8e0cd2c.png)

 我们可以将我们的程序保存到服务器上，比如我们选择保存到 “**文件（主目录）**”，文件名为PrintClass.sas

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/35d9a46b-9493-49e6-8cd5-0944f6dd9713.png)](http://igeekbar.com/igeekbar/networks/uploadimg/35d9a46b-9493-49e6-8cd5-0944f6dd9713.png)

 实际上，该文件保存到了服务器上的文件 /home/yinliangwu0/PrintClass.sas 中。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/800ffd97-0497-4d3f-b43b-54b27aedcaa9.png)](http://igeekbar.com/igeekbar/networks/uploadimg/800ffd97-0497-4d3f-b43b-54b27aedcaa9.png)

 由于 WORK 是临时逻辑库，在SAS会话结束时系统会自动删除。如果我们要在服务器磁盘上**永久保存**该临时导入的数据集 WORK.class，我们可以在导入之前指定一个非临时逻辑库来保存数据、或者如下：我们新建一个逻辑库 mylib ，然后在 mylib 中生成一份WORK.CLASS的拷贝。如下：

```
libname mylib “/home/yinliangwu0”;
 data mylib.class;
   set work.class;
run;
```

这样我们就可以将我们的打印class 代码改为：

```
proc print data=mylib.class;
run;
```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/c1f0585e-b285-4212-a568-b3e74f7f2812.png)](http://igeekbar.com/igeekbar/networks/uploadimg/c1f0585e-b285-4212-a568-b3e74f7f2812.png)

 运行上面的代码后，我们可以看到服务器的“逻辑库/我的逻辑库” 中多了 MYLIB，其中还包括数据 CLASS。 

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/53c4f432-9357-4497-acbc-9d7357c9ac9e.png)](http://igeekbar.com/igeekbar/networks/uploadimg/53c4f432-9357-4497-acbc-9d7357c9ac9e.png)

 其对应的物理文件就是：服务器 odaomr.oda.sas.com 的 /home/yinliangwu0/class.sas7bdat

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/6822c0fb-87ab-4f4b-b354-531aede16e9e.png)](http://igeekbar.com/igeekbar/networks/uploadimg/6822c0fb-87ab-4f4b-b354-531aede16e9e.png)

 

这样，我们完成了上传数据集，并将数据保存在了非临时逻辑库。同时也在服务器上编写完了SAS 程序 PrintClass.sas，我们就可以随时注销，关闭SAS Studio 应用了。

 鼠标点击右上角的 “注销” 菜单即可。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/932aa71b-5fc7-46eb-8d46-94a692aa0614.png)](http://igeekbar.com/igeekbar/networks/uploadimg/932aa71b-5fc7-46eb-8d46-94a692aa0614.png)

 安全退出后应关闭浏览器。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/5dd9a059-e27d-4a9d-a785-5708b4eebaca.png)](http://igeekbar.com/igeekbar/networks/uploadimg/5dd9a059-e27d-4a9d-a785-5708b4eebaca.png)

 由于所有数据都保存在云端，因此你下次登录时所有的数据和程序都还在，你可以随时继续你的分析工作… 也可以随时保存工作并退出！

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/67f96187-1288-4711-9e1c-ffdf82e2888b.png)](http://igeekbar.com/igeekbar/networks/uploadimg/67f96187-1288-4711-9e1c-ffdf82e2888b.png)

 

4.       以下分享若干提示信息：

a)         **检查SAS Studio** **和后台SAS****平台的版本信息**：点击右上角？号，然后选择“关于 SAS® Studio” 即可查看。

 

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/b6d53a0f-84e8-4a04-806d-59b27a267138.png)](http://igeekbar.com/igeekbar/networks/uploadimg/b6d53a0f-84e8-4a04-806d-59b27a267138.png)

 

b)         **查看系统默认的文本编码**：从右上角“**其他应用程序选项**”按钮入口，选择 **参数选择->****常规->** **默认文件编码**：UTF-8 ，该选项设定读取/保存 SAS 程序代码的默认编码。我们在中文平台上创建的SAS程序文件默认编码为 GB2312。而SAS SODA 系统默认采用 UTF-8 处理文件读写和数据处理，因此建议上传文件/上传代码之前确保文件编码为 UTF-8 编码。记住，该选项并不影响我们前面提到过的导入数据功能，因此即使在此修改此文本编码为 GB2312，也不会修正从客户端上传的GB2312编码的数据导入到SAS系统环境中，因为 GB2312和系统默认会话编码 UTF-8 之间的不一致问题。 

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/43edc707-64dd-4e66-b4ec-828f569cc90f.png)](http://igeekbar.com/igeekbar/networks/uploadimg/43edc707-64dd-4e66-b4ec-828f569cc90f.png)

 

c)         在参数选择中 “启用提示” 可以改善我们的程序编辑器行为，从而让我们可以在进行SAS 编程的时候获得必要的提示信息（如下图）。 

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/05ad0f3e-8d2e-4689-b9b1-291908536487.png)](http://igeekbar.com/igeekbar/networks/uploadimg/05ad0f3e-8d2e-4689-b9b1-291908536487.png)

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/623d9432-e417-4ea0-b3f6-d843dcd81f7f.png)](http://igeekbar.com/igeekbar/networks/uploadimg/623d9432-e417-4ea0-b3f6-d843dcd81f7f.png)

d)         在SAS Studio 中利用** “代码段”** 可以让我们方便地重用一些代码片段，比如我们可以在代码编辑窗口中任意选中某些代码（如下蓝色部分），然后点击工具栏“添加至我的代码段” 按钮，即可命名特定代码片段。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/195f49c7-30e2-4735-8347-c0d39c4b5137.png)](http://igeekbar.com/igeekbar/networks/uploadimg/195f49c7-30e2-4735-8347-c0d39c4b5137.png)

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/2d990bf9-c201-4721-a6f2-989ad9cff0d9.png)](http://igeekbar.com/igeekbar/networks/uploadimg/2d990bf9-c201-4721-a6f2-989ad9cff0d9.png)

 这样我们在新建另一个SAS 程序的时就可以很方便地在程序编辑器中 “双击” 添加左侧选中的代码片段了。比如下面我们编写的一个简单的对 mylib.class 的数值变量计算平均值和极差的程序，需要插入DisplayLogo 信息。

```
libname mylib "/home/yinliangwu0"; 
proc means data=mylib.class;
  var age weight height ;
run;
```

运行我们的代码然后保存到 MeansClass.sas中：

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/14df9330-ddf2-4a69-ae0d-8b2253d31852.png)](http://igeekbar.com/igeekbar/networks/uploadimg/14df9330-ddf2-4a69-ae0d-8b2253d31852.png)

 e)         创建自动执行代码：SAS支持在系统启动时自动执行某些程序，比如我们希望保存在磁盘特定目录的数据，在每次我们登录到SAS工作环境的时候可以用于分析，我们可以将libname 语句加入到 AutoExec文件中。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/01008b3e-62c7-44bc-a9aa-e902924b67f6.png)](http://igeekbar.com/igeekbar/networks/uploadimg/01008b3e-62c7-44bc-a9aa-e902924b67f6.png)

 相应地，代码中 libname mylib "/home/yinliangwu0"; 就可以注释掉了。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/0dbc6e82-f2ec-45a0-92b2-8c674d1c4b48.png)](http://igeekbar.com/igeekbar/networks/uploadimg/0dbc6e82-f2ec-45a0-92b2-8c674d1c4b48.png)





## 05 - 操纵数据

操纵数据是数据学家的重要工作内容之一，主要用来为数据分析或创建报表准备必要的内容。传统数据仓库领域的数据工作（ETL或ETCL）——**数据的抽取（Extract）、转换（Transformation）、清洗（Clean）和加载（Load）**都是数据科学家的家常便饭。

 

#### - SAS 逻辑库（SAS Library）

SAS 组织管理数据的最基本单位是**SAS 逻辑库（SAS Library）和SAS 数据集（SAS Dataset）**。细心的读者也许会记得SAS的HelloWorld 程序，第一行都是以 Data 语句开头？因为 SAS 语言就是面向数据分析的专门语言，在SAS的世界里**数据是分析的基础，也是从数据到智能的基石**。后面我们会逐渐领略到 “数据就是分析的基础” 这一精髓！

SAS 逻辑库是SAS为面向数据处理而设计的 **引用和存储** 单位，是SAS组织数据的顶级单位。一个SAS 逻辑库可以包含若干 成员（Member），其中最常用的成员为 **SAS**数据集（SAS Dataset）。**SAS 逻辑库和 SAS数据集的概念可分别对应传统关系型数据库（RDBMS）的数据库和数据表的概念**，但SAS 逻辑库包含更加丰富的数据内容和灵活的结构。

SAS 系统预定义了若干系统逻辑库，每次启动SAS运行环境（也称为建立一个SAS会话）的时候，这些逻辑库就已经自动建立，供用户使用。一般包含5个**永久库**（sasuser，sashelp和3个地图专用的逻辑库：maps、mapsgfk、mapssas）和一个**临时库** work。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/ba396c46-cb30-4770-b0f4-261fcd2ee8e1.png)](http://igeekbar.com/igeekbar/networks/uploadimg/ba396c46-cb30-4770-b0f4-261fcd2ee8e1.png)

 

1． **临时库（WORK）**：每次启动 SAS 运行环境的时候，SAS都会有一个临时逻辑库 work被建立。临时库 work 用于在SAS 会话期间临时存储和访问数据，SAS 会话结束（即退出SAS运行环境）后临时库work和其中的内容会被自动删除。

比如：在Windows 平台的SAS中，每次启动一个SAS会话，系统会在操作系统临时目录**%TEMP%**下的“SAS Temporary Files”目录中创建一个**会话特定的临时路径**（比如：C:\Users\sbjyiw\AppData\Local\Temp\SAS Temporary Files\ **_TD8212_SBJYIW_**），这是SAS 会话期间存放各种临时数据的磁盘路径。

 

2．  **永久库**：永久库中的数据并不因SAS 会话结束而消失，也就是SAS运行结束后那些数据依然存在。SAS 会话的永久库由SAS启动过程中使用的那个配置文件 sasv9.cfg 来指定。

注意：SAS几乎支持所有的语言和编码，在SAS 安装环境中sasv9.cfg 配置文件有多个，默认提供**英文版**、**支持****DBCS****的英文版**，**Unicode****版**、和**十余种语言特定的版本**，对应SAS 安装后的启动菜单。sasv9.cfg 也支持使用 -config 参数指向另一个配置文件sasv9.cfg 来重用其设置，从而构成配置文件体系。

 

**sashelp**：逻辑库 sashelp是系统预定义的**只读逻辑库**，提供系统初始化后可用的数据。逻辑库sashelp 在sasv9.cfg 中由以下配置被映射到多个目录，从中读取可用的数据集文件。

```
-SASHELP (
        "!SASCFG\SASCFG"
        "!SASROOT\nls\zh\sashelp"
        "!SASROOT\core\sashelp"
                       …
        )
```

**sasuser**：逻辑库 sasuser是系统预定义的**可写逻辑库**，用来在SAS 会话运行期间**存放当前用户特定的数据**。一般用来隔离不同SAS用户数据。

 

逻辑库 sasuser 在sasv9.cfg 中使用 -SASUSER 指定，对应于**操作系统中的用户主目录**或者**数据库中的特定用户数据库**。比如在 Windows 系统中，-SASUSER 被指向　"?CSIDL_PERSONAL\My SAS Files\9.3"，比如：C:\Users\sbjyiw\Documents\My SAS Files\9.3

 

3．  **用户库**：也称用户自定义逻辑库，用户可以在 SAS程序中用libname 语句自定义若干用户库，用来引用存放于磁盘上或者其他数据库服务器上的数据。比如：

```
 libname mylib 'c:\temp'; *定义我的逻辑库;
```

 *在 mylib 中创建系统逻辑库 sashlep.class 的拷贝，实际上文件存于 c:\temp;

```
data mylib.foo;
     set sashelp.class;
run;
```

*打印我的数据 mylib.foo，实际上引用 c:\temp\foo.sas7bdat;

```
proc print data=mylib.foo;
run;
```

不管SAS运行在什么操作系统上，你可以用同样的**逻辑库引用名**（Library reference name）来引用你的SAS 逻辑库，逻辑库引用名是当前SAS会话能够识别的逻辑名称，指向某个操作系统能够识别的物理位置或者数据访问引擎的访问入口。逻辑库引用在SAS代码中**隔离了操作系统或数据库系统的物理位置，提高了代码的可移植性**。

 

你也可以在任何需要的时候，**改变某个逻辑库引用的物理指向**或者**清除已经分配的某个逻辑库引用**。

 

*注意: 改变逻辑库 mylib 的指向为 c:\windows;

```
libname mylib "c:\windows";
```

*注意: 清除逻辑库 mylib, 此语句后 mylib 将不再可用; 但SAS并不删除c:\temp 目录中任何物理文件内容;

```
libname mylib clear;
```

在SAS代码里，如果你想要删除　c:\temp 目录中的物理文件 foo.sas7bdat,可以调用如下语句：

 *删除数据集 mylib.foo，磁盘上的物理文件也相应删除;

```
proc datasets library=mylib;
   delete foo;
run;
```

**在 SAS 运行环境中，你可以用鼠标右键点击逻辑库来查看逻辑库的属性，如下。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/2f1faffc-b9bc-4695-97d5-71e730c83ca7.png)](http://igeekbar.com/igeekbar/networks/uploadimg/2f1faffc-b9bc-4695-97d5-71e730c83ca7.png)

你也可以使用 libname 语句的 LIST功能在日志窗口中显示逻辑库信息，你也可以使用关键字_ALL_　来列出系统中所有可用的逻辑库的信息。

 ```
libname mylib LIST;
 ```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/10a4cd66-e4a1-4eea-9030-41f1eae3780e.png)](http://igeekbar.com/igeekbar/networks/uploadimg/10a4cd66-e4a1-4eea-9030-41f1eae3780e.png)

 ```
libname ALL LIST;
 ```

输出如下：

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/1b5c5f99-9815-490c-bba9-6e6823544dda.png)](http://igeekbar.com/igeekbar/networks/uploadimg/1b5c5f99-9815-490c-bba9-6e6823544dda.png)





#### - SAS数据集（Dataset）

 

SAS 数据集是一种SAS特定的结构化数据文件，这种表状数据由变量（列）和观测（行）组成。变量和观测对应传统数据库中表的列和行**。

 

SAS数据集从结构上看包括 **描述部分** 和 **数据部分**。描述部分是数据的元数据，主要包括**数据集的属性信息**，比如**数据集名称**、**文件编码**、**创建日期**，**观测数目**（行数）、**变量数目**（列数）、以及**每一个变量的具体属性定义**（名称、类型、长度、标签、输入/输出格式）等。数据部分就是**每一行记录本身**。要查看数据集的元数据，可以使用 **PROC CONTENTS** 过程步来显示。

 ```
proc contents data=sashelp.class;
run;
 ```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/834e9343-70c4-471e-97a5-ad19252039d7.png)](http://igeekbar.com/igeekbar/networks/uploadimg/834e9343-70c4-471e-97a5-ad19252039d7.png)

 

在 SAS 代码中，数据集 [Libref.]dsname 两级名称进行引用，如果是临时库 **WORK**中的数据，则可以省略逻辑库引用名。

 

- SAS 数据集中的每一列，在SAS代码里称为**变量**，其名称由**1-32****字节长的字母、下划线和数字组成，但不能以数字开始**。SAS内部用**大写形式创建变量**，故SAS代码中不区变量名称的大小写。
- SAS变量类型包括 **字符型** 和 **数值型** ，缺省都是**8****字节长**。**字符类型**的变量值可为**1-32767****个字节**，**数值型**可为**2-8****任意字节长的整数或浮点数**(Windows/Linux为3-8，IBM大型机为 2-8)。

 注意：这儿谈论的SAS变量类型是传统意义上SAS数据集中的数据类型，在后面章节中我们将看到其实SAS代码能支持更加丰富的数据类型。然而,一旦持久化到SAS数据集后则只有定长字符型和数值型两大类数据类型。

- SAS变量的**输出格式**用于指定**该变量（列）** **的缺省输出格式**。这样相同的**SAS****内部存储值**可以根据不同的**输出格式**生成不同的字符串表达。SAS 变量的**输入格式**则用于告诉SAS按照该输入格式从外部数据源读取数据到SAS 数据集中。下面将重点讲一下SAS输入输出格式。

 

**SAS** **输入输出格式**

 

SAS 输入/输出格式就是**一个包含小数点** **.** **的特殊字符串**，完整的格式包括**格式前缀** **$****（**字符型专用**）**、**格式名称** **formatname**，**输出宽度****w**，**小数点位数** **d**（数值型专用）等信息。完整形式如下：

 ```<*$*>**formatname**<*w*>.<*d*>```

 

输入/输出格式是 字符串形式的语义表达和 SAS**内部存储** 之间的桥梁。根据SAS数据类型的不同分为**字符型格式**和**数值型格式**两大类型，其中数值类型格式还包括用于**数值**，**货币**，**日期/时间/日期时间**等三个子类的格式。**格式用于输入称为INFORMAT（输入格式），用于输出称为FORMAT（输入出格）。**

 

**字符型格式**必须在格式名前面加美元符 **$** （其实是源于英文字符串 String的首字母） 表示，w表示输出的总宽度。对于数值型变量，还可以指定小数点后的位数d。比如：

- l  字符型格式：$w.
- l  数值格式：w.d

1)         COMMAw.d       表示用逗号, 做千位分隔符，小数点

2)         COMMAXw.d     表示用小数点做千位分隔符，逗号作小数点，与COMMA相反，用于欧洲部分国家的数值显示。

- l  货币：

1)         DOLLARw.d     表示变量按美元格式输出：美元符号开头，逗号千位分隔符，小数点

2)         EUROw.d    表示变量按欧元格式输出：欧元符号，逗号千位分隔符，小数点

3)         EUROXw.d        与EURO相同，但以小数点做千位分隔符，逗号作小数点

 

运行如下代码，检查输出结果： 

```
data null;
   c="abcdefghijklmn"; *14bytes;
   put "char=" c;
   put "char=" c $;
   put "char=" c $14.;

   n=1234.567890;
   put "w.d=   " n 12.3;
   put " COMMAw.d=" n COMMA12.3;
   put "COMMAXw.d=" n COMMAX12.3;

   put "DOLLARw.d=" n DOLLAR12.3;
   put "  EUROw.d=" n EURO12.3;
   put " EUROXw.d=" n EUROX12.3;
run;
```

系统输出：

char=abcdefghijklmn

char=abcdefghijklmn

char=abcdefghijklmn

w.d=       1234.568

COMMAw.d=   1,234.568

COMMAXw.d=   1.234,568

DOLLARw.d=  $1,234.568

EUROw.d=  E1,234.568

EUROXw.d=  E1.234,568

 

- l  日期格式：

1)         DATEw. 比如DATE7. 显示 16JAN17

2)         MMDDYYw. 比如 MMDDYY10. 显示 01/01/1960

3)         YEAR4. 显示 1960

4)         NLDATE. 显示本地语言格式的日期，比如中文SAS上显示 *2017**年01月22日*

- l  时间：

1)         TIMEw. 比如 TIME. 显示 22:16:27

2)         NLTIME. 显示本地语言格式的时间，比如中文SAS上显示 *17**时18分30秒*

- l  日期时间：

1)         DATETIME. 比如 DATETIME. 显示 16JAN17:22:14:35

2)         NLDATM. 显示本地语言格式的日期时间，比如 *2017**年01月22日 17时18分30秒*

```
data null;
   mydate=today();
   put mydate DATE. ;  

   put mydate MMDDYY.;
   put mydate YEAR.;

   mytime=TIME() ;
   put mytime TIME.;

   mydt=datetime();
   put mydt DATETIME.;

   put mydate NLDATE.;
   put mytime NLTIME.;
   put mydt NLDATM.;
run;
```

系统输出：

22JAN17

01/22/17

2017

17:18:31

22JAN17:17:18:31

2017年01月22日

17时18分30秒

2017年01月22日 17时18分30秒

 

**结语：**SAS 数据集是SAS 组织数据的容器，更上一级采用SAS 逻辑库进行组织。SAS 数据集包含描述数据的**元数据部分**（表的属性以及行列定义），以及**真正包含数据的观测（数据行）组成**。不管数据是存在磁盘上，还是在外部数据库或应用系统中，在SAS 内部都统一通过**逻辑库引用** 进行访问，用户无须关注数据的存储细节，而是关注数据在分析层次的表达。

 

SAS 数据集中的观测（表记录）一般有三种生成方式： 

1） DATA 步通过内嵌数据行、基于已有的数据集、或者外部数据库/系统来生成。

2）SAS数据集通过 PROC IMPORT 或者其他 面向数据操作的PROC （如 PROC SQL）生成；

3）通过面向分析的PROC自动生成，一般为间数据或分析结果数据。下面我们以生成一个最简单的数据集作为本章结束，理解SAS数据集的结构。

```
libname mylib 'c:\temp';
data mylib.mydata (label="This is my first data");
   length column1 $32;
   column1="The only constant is change";

   column2=1234.5678;
   format column2 dollar10.2;

   label column1="This is Char column";
   label column2="This is Num column";
run;
 
proc contents; run;
proc print; run;
```

  

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/bb2bbedc-8582-48ce-8ee5-c351823709e7.png)](http://igeekbar.com/igeekbar/networks/uploadimg/bb2bbedc-8582-48ce-8ee5-c351823709e7.png)

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/f7739f30-c105-4359-bda0-0826efa47bdc.png)](http://igeekbar.com/igeekbar/networks/uploadimg/f7739f30-c105-4359-bda0-0826efa47bdc.png)



## 06 - DATA步与PDV

在BASE SAS 中，DATA 语句用于开始一个数据步， 后续为若干DATA步特定的语句；SAS数据步结束于**下一个** **DATA** **步**或 **PROC** **步开始之处，**或者结束于后续**显式指定的**RUN**语句**。

 

注意：DATA 步是SAS编程语言的基础，它可以执行在多种执行环境中。本章要讲的是传统意义上的SAS DATA步，后面我们会讲到下一代DATA步以及DATA步在SAS 云分析服务环境中执行的情况。千里之行，始于足下！我们还是从传统 DS 开始吧…

 

#### - DATA 语句最常见的调用方式

###### 1）  DATA 语句可**不指定任何参数**

则DATA 步将**自动创建一个目标数据集 DATA*n*，其中 n 为从1开始不断增长的唯一整数。 **

比如下面的SAS代码将在临时逻辑库 WORK中创建数据集 Data1，包含1行5列数据。再次运行该代码时将生成 Data2…依次类推。

```
DATA;
       Name="Leon"; Sex="M"; Age=30; Weight=83.5; Height=175; 
run;
```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/8ca6bb02-2f78-4051-bc88-dd53d15ec261.png)](http://igeekbar.com/igeekbar/networks/uploadimg/8ca6bb02-2f78-4051-bc88-dd53d15ec261.png)

注意：这种方式一般用来生成不在乎输出数据集名称的时候，但由于每次执行都会在 WORK 中生成一份新的数据，一般不建议这种用法。通常情况下会显式指定输出数据集的名字会更好一些。

 对于这种临时数据，我们依然可以使用系统宏变量 &SYSLAST来跟踪，比如下面的代码用来显示上一次生成的临时数据集的名字，并从WORK中删除它。

``` 
data null;
    put "&SYSLAST";
run;

proc datasets nolist ;         
    delete %scan(&SYSLAST,2);
quit;
```

###### 2）  DATA 语句也可以**指定数据集名称** 

**_NULL_** ，表示不输出任何目标数据集，通常用于纯粹的计算逻辑处理。也经常用于调试SAS代码。

###### 3）  DATA 语句也**可以指定多个输出数据集**

从而实现在一个DATA步里输出各种需要的数据。比如下面的代码将同时生成两份内容相同的数据集 data1和data2。

``` 
DATA data1 data2;
Name="Leon"; Sex="M"; Age=30; Weight=83.5; Height=175; 
run;
```

 一般情况下，我们会**显式指定生成一个目标数据集名称**，并且希望放在特定的目录中。SAS DATA语句在数据处理中可以展现出令人惊异的行为，比如我们希望把 sashelp.class 中两种性别的数据分成两个数据集 classF和clasM，可使用下面的代码简洁地实现。

```
proc print data=sashelp.class;
run;

DATA classF classM;
    set sashelp.class;
    if sex="F" then output classF; /Split F to ClassF/
    else            output classM; /Split M to ClassM/
run;

proc print data=classF; run;
proc print data=classM; run;
```



上一章的最后，我提到数据集中的观测（记录）有各种生成方式，下面我们就一起看看在SAS中如何做到。

- l  利用内嵌数据行创建SAS数据集

 一般情况下，如果我们要生成的数据量比较小，且不希望有独立的数据文件，我们可以直接将数据嵌在SAS代码中，内嵌数据行有几种不同的方式：

 1） 最常见的情况是我们有一系列的数据行，数据项之间用空格分隔。这种情况我们可以使用datalines 语句配合input 语句直接生成。datalines语句表示下一行将包含数据行。由于数据行并非语句，所以它不需要分号。另外，除了 **datalines 语句外，我们也可使用 lines （datalines语句的别名）或 cards 语句，三者等价。**

```
libname mylib "c:\temp";
DATA mylib.myclass;
  input Name $ Sex $ Age Height Weight; /$ 表示字符型变量/
  datalines;
Alfred M 14 112.5 69
Alice F 13 84 56.5
Barbara F 13 98 65.3
Carol F 14 102.5 62.8
Henry M 14 102.5 63.5
James M 12 83 57.3
Jane F 12 84.5 59.8
Janet F 15 112.5 62.5
Jeffrey M 13 84 62.5
John M 12 99.5 59
Joyce F 11 50.5 51.3
Judy F 14 90 64.3
Louise F 12 77 56.3
Mary F 15 112 66.5
Philip M 16 150 72
Robert M 12 128 64.8
Ronald M 15 133 67
Thomas M 11 85 57.5
William M 15 112 66.5
RUN;
```

系统会生成如下数据集，存放在 C:\temp 目录中。与利用临时库 WORK不同，该数据集在你SAS 会话结束后依然存在，存放在 C:\temp\class.sas7bdat 文件中。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/0a343e29-af33-4ec5-b84e-e4594e8a7dda.png)](http://igeekbar.com/igeekbar/networks/uploadimg/0a343e29-af33-4ec5-b84e-e4594e8a7dda.png)

注意：生成到磁盘上的文件名依赖于操作系统的文件系统，Windows平台的FAT/NTFS不区分大小写，而Linux/Unix 则区分大小写，SAS一律使用小写字母生成数据集文件，在Unix/Linux平台上，如果我们要读取包含大写字母的文件名（即数据集名）时，需要启用系统选项VALIDMEMNAME=EXTEND，并且数据集的名字必须与磁盘上的文件名大小写完全匹配。

 

2） 如果**数据行包含特定的分隔符**，我们可以利用 *infile* 语句来指向特殊的文件引用 *datalines* ，并且使用参数 *delimiter*=’<分隔符>’ 来指定分隔符。比如：

 ```
libname mylib "c:\temp";
DATA mylib.myclass;
  infile datalines delimiter=',';
  input Name  Sex  Age Height Weight;
  datalines;
Alfred,M,14,112.5,69
Alice,F,13,84,56.5
Barbara,F,13,98,65.3
Carol,F,14,102.5,62.8
Henry,M,14,102.5,63.5
James,M,12,83,57.3
Jane,F,12,84.5,59.8
Janet,F,15,112.5,62.5
Jeffrey,M,13,84,62.5
John,M,12,99.5,59
Joyce,F,11,50.5,51.3
Judy,F,14,90,64.3
Louise,F,12,77,56.3
Mary,F,15,112,66.5
Philip,M,16,150,72
Robert,M,12,128,64.8
Ronald,M,15,133,67
Thomas,M,11,85,57.5
William,M,15,112,66.5
RUN;
 ```

3） 如果**数据行本身包含分号**（注：由于分号是SAS语句的结束符，因此很特别），我们该如何处理呢？我们可以使用 **datalines4** 语句来完成。也可以使用该语句的别名为 cards4 或lines4。**datalines4** 语句必须使用**4**个连续的分号开始的一行来标记数据行结束。下面的例子中，字符型列 Name 包含分号，则我们必须以datalines4 来输入数据。

```
libname mylib "c:\temp";
DATA mylib.myclass; 
  input Name  Sex  Age Height Weight;
  datalines4;
Alfred; M 14 112.5 69
Alice; F 13 84 56.5
Barbara; F 13 98 65.3
Carol; F 14 102.5 62.8
Henry; M 14 102.5 63.5
James; M 12 83 57.3
Jane; F 12 84.5 59.8
Janet; F 15 112.5 62.5
Jeffrey; M 13 84 62.5
John; M 12 99.5 59
Joyce; F 11 50.5 51.3
Judy; F 14 90 64.3
Louise; F 12 77 56.3
Mary; F 15 112 66.5
Philip; M 16 150 72
Robert; M 12 128 64.8
Ronald; M 15 133 67
Thomas; M 11 85 57.5
William; M 15 112 66.5
;;;;
RUN;
```

4） 如果**数据行本身是变长**(比如字符串变量包含空格字符)，也就是说**数据行参差不齐**，那我们如何输入呢？我们可以使用SAS提供的**列指针**，用来明确指定数据行中**变量的读取的起止位置**，从而正确读取变长的字符串。比如：

 ```
libname mylib "c:\temp";
DATA mylib.myclass;
  input Name $1-15 Sex $ Age Height Weight; 
  datalines;
Alfred Liu      M 14 112.5 69
Alice Wang      F 13 84    56.5
Barbara Deng    F 13 98    65.3
Carol Zhang     F 14 102.5 62.8
Henry Kissinger M 14 102.5 63.5
James Michalle  M 12 83    57.3
Jane Xu         F 12 84.5  59.8
Janet Quin      F 15 112.5 62.5
Jeffrey Smith   M 13 84    62.5
John Albert     M 12 99.5  59
Joyce Betty     F 11 50.5  51.3
Judy Yang       F 14 90    64.3
Louise Bernard  F 12 77    56.3
Mary Kushiner   F 15 112   66.5
Philip Pebble   M 16 150   72
Robert Chu      M 12 128   64.8
Ronald Wiese    M 15 133   67
Thomas Berryman M 11 85    57.5
William Wu      M 15 112   66.5
RUN;
 ```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/d6cb78d6-cc9d-4a8c-a250-6eeb545a5061.png)](http://igeekbar.com/igeekbar/networks/uploadimg/d6cb78d6-cc9d-4a8c-a250-6eeb545a5061.png)

5） 有的同学会问，如果我们在**一个数据行上包括多个观测（记录）**，我们该如何读取？SAS在 input 语句上设计了一个**特殊的参数** **@@**，**用来告诉SAS **从数据行完整读取一个观测后，不要马上读入下一个数据行，而是继续从当前行的缓冲区中读取数据填充观测**。这为我们节省代码文件的行数非常有用。比如：

```
libname mylib "c:\temp";
DATA mylib.myclass;
  input Name  Sex  Age Height Weight @@; 
  datalines;
Alfred M 14 112.5 69
Alice F 13 84 56.5    Barbara F 13 98 65.3
Carol F 14 102.5 62.8 Henry M 14 102.5 63.5 James M 12 83 57.3
Jane F 12 84.5 59.8   Janet F 15 112.5 62.5 Jeffrey M 13 84 62.5
John M 12 99.5 59     Joyce F 11 50.5 51.3  Judy F 14 90 64.3
Louise F 12 77 56.3   Mary F 15 112 66.5    Philip M 16 150 72
Robert M 12 128 64.8  Ronald M 15 133 67   
Thomas M 11 85 57.5   William M 15 112 66.5
RUN;
```

- l  基于外部文件创建SAS数据集

大部分情况下，**数据来自于磁盘上的某个外部文件**，而且通常不是一系列的文件。比如在C:\temp目录中有如下文本文件： myclass.txt, 我们怎么用 DATA 步来读取呢？

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/a9797847-c8e0-4e52-ab3b-96c48ce60af9.png)](http://igeekbar.com/igeekbar/networks/uploadimg/a9797847-c8e0-4e52-ab3b-96c48ce60af9.png)

我们不需要 datalines语句，而是在 DATA 步内利用** infile** 语句指定该外部文件(相当于我们将datalines语句下的数据行移入了外部文件)。然后再用 input语句读入。比如：

 ```
libname mylib "c:\temp";
DATA mylib.MyClass;
  infile  'c:\temp\myclass.txt';
  input Name  Sex  Age Height Weight;   
RUN; 
 ```

系统将创建一个完整的数据集 mylib.MyClass。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/db2c8dae-b240-49e3-bb7e-03b73fd9e50a.png)](http://igeekbar.com/igeekbar/networks/uploadimg/db2c8dae-b240-49e3-bb7e-03b73fd9e50a.png)

还有一种更加标准的做法是，我们先用 filename 语句定义一个文件引用 myfile，然后再在 infile 语句中使用该文件引用。代码如下：

 ```
libname mylib "c:\temp";
filename myfile 'c:\temp\myclass.txt';
DATA mylib.MyClass
  infile myfile;
  input Name  Sex  Age Height Weight;   
RUN;
 ```

就像前面已经提到的一样，数据行中可能包含说明文字，或者数据的表头什么的。这种情况下我们可以在 infile 语句上指定**开始读取观测的行** firstobs=，同时也可以指定**结束读取观测的行**obs= 用来限定读入的数据量，通常结果集的总行数为 **obs-firstobs+1** 行。比如下面的代码读入第二行开始的10行数据。

``` 
infile myfile  delimiter=',' firstobs=2 obs=11;
```



####  - 简单比较SAS数据集

为了验证我们自己创建的数据集 *MyLib.myclass* 和系统 *SASHELP.CLASS* 数据集的差异，我们可以调用 PROC COMPARE 来比较两个数据集的异同。

 ```
proc compare base=sashelp.class compare=mylib.myclass;
run;
 ```

系统显示两个数据集基本相同，除了 sashelp.class 有数据集Label信息，Sex 列宽度为8字节外，两个数据集完全一样。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/86a0a7ce-1820-412c-8274-9bc663c09006.png)](http://igeekbar.com/igeekbar/networks/uploadimg/86a0a7ce-1820-412c-8274-9bc663c09006.png)

#### - 生成SAS数据集

##### A. 通过已有的SAS 数据集生成数据

 很多时候我们都是操作已有的SAS数据集，来进行各种操作生成目标数据集。比如对数据集中数据的增删改查，数据集的排序、合并、分离、转置等。

###### 1)   增加数据行：在数据集尾部增加数据行

```
DATA OneRow;
    Name="Leon"; Sex="M"; Age=30; Weight=83.5; Height=175; 
run;

data Class2;
    set sashelp.class OneRow;
run;
```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/270cd13c-6c86-427b-a683-62fda7d6816f.png)](http://igeekbar.com/igeekbar/networks/uploadimg/270cd13c-6c86-427b-a683-62fda7d6816f.png)

​    也可以在数据的头部增加数据行，只需要改变 SET 语句中的数据集顺序即可。

 ```
DATA OneRow;
     Name="Leon"; Sex="M"; Age=30; Weight=83.5; Height=175;
run;

data myclass;
    set OneRow sashelp.class;
run;

proc print data=myclass;
run;
 ```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/54ad24ee-c505-4575-9405-706e7beba1d0.png)](http://igeekbar.com/igeekbar/networks/uploadimg/54ad24ee-c505-4575-9405-706e7beba1d0.png)

注意：细心的读者可能会发现，输出的数据集中Name有截断错误，原因是在 SET语句时 PDV 的初始结构来自于我们创建的临时数据集 OneRow，而该数据集中变量Name的长度定义不够，可以通过增加临时数据集宽度定义来修正。

 ```
DATA OneRow; 
    length Name $8;
    Name="Leon"; Sex="M"; Age=30; Weight=83.5; Height=175; 
run;
 ```

​    如果需要在特定行处插入数据，可以使用内部计数器 _N_ 作条件实现：

```
DATA myclass;
    set sashelp.class;
    if N = 1 then do;  /在第一行后面插入数据/
       output;
       Name="Leon"; Sex="M"; Age=30; Weight=83.5; Height=175; 
    end;
    output;
run;

option obs=3; /列出前三行/
proc print data=myclass;
run;
```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/c442b7b0-2696-4436-9e5b-8d8c1e3e58da.png)](http://igeekbar.com/igeekbar/networks/uploadimg/c442b7b0-2696-4436-9e5b-8d8c1e3e58da.png)

 

###### 2） 删除数据行：删除第三行数据

```
data myclass;
    set sashelp.class;
    if N = 3 then return;
    else output;
run;

proc summary data=myclass print; 
run;
```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/971fcf06-caee-410e-b972-fe352cdc8915.png)](http://igeekbar.com/igeekbar/networks/uploadimg/971fcf06-caee-410e-b972-fe352cdc8915.png)

 

当然你也可以删除满足指定条件的数据行

```
data myclass;
    set sashelp.class;
    if Sex = 'M' then return;
    else output;
run;

proc print data=myclass;
run;
```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/ed0a92ba-2a45-4491-95fa-31280c32e9f5.png)](http://igeekbar.com/igeekbar/networks/uploadimg/ed0a92ba-2a45-4491-95fa-31280c32e9f5.png)



###### 3） 修改数据行： 满足特定条件时修改变量的值，比如把第三行的Name改为 "Baby".

 ```
Data myclass;
    set sashelp.class;
    if N = 3 then name="Baby";   
run;

options obs=3;
proc print; 
run;
 ```

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/9e1b406e-474a-4af1-ada4-1c77642fddc3.png)](http://igeekbar.com/igeekbar/networks/uploadimg/9e1b406e-474a-4af1-ada4-1c77642fddc3.png)



###### 4)    查询特定数据行：仅输出满足特定条件的数据行

```
libname mylib "c:\temp";
data mylib.myclass;
    set sashelp.class;
    if name="Alfred" then output;  
run;

proc print data=mylib.myclass;
run;
```

##### B. 通过 PROC IMPORT 或PROC SQL 生成

SAS 提供PROC IMPORT 和 PROC EXPORT 来将数据导入/导出 SAS 运行环境，常用的数据文件格式为逗号分隔的 CSV 和微软的电子表格 EXCEL 文件，我们可以使用如下代码简单完成。

```
proc import
  datafile='c:\temp\class.csv' dbms=csv out=class replace;
  getnames=YES;
  mixed=NO;
run;

proc print data=class;
run;

proc import
  datafile='c:\temp\class.xlsx' dbms=xlsx out=class  replace;
  getnames=YES;
  mixed=NO;
run;
```

注意：以上例子需要数据文件 c:\temp\class.csv 和 class.xlsx，你可以用 proc export 进行生成。

```
PROC EXPORT  data=sashelp.class  outfile='c:\temp\class.xlsx' dbms=xlsx replace;
run;

PROC EXPORT  data=sashelp.class  outfile='c:\temp\class.csv' dbms=csv replace;
run;
```

 

注意：很多人根据帮助文档使用 dbms=EXCEL 导入 EXCEL 文件时会出现如下错误：

ERROR: Connect: 没有注册类

ERROR: Error in the LIBNAME statement.

根本的原因是 dbms=EXCEL 和 dbms=xlsx 在 SAS 里访问机制不同，前者需要安装 ACE 引擎才能工作，而默认情况下我们并没有安装它。这是一个令很多程序员困惑的技术陷阱。

 

PROC SQL 让 SAS 可以调用结构化查询语言 SQL 进行数据操作，广泛用于关系数据库管理系统的数据表和视图的增删改查，但SAS 技术更高一筹，也可以对 SAS 数据集进行标准的 SQL 操作。主要功能包括：创建数据表和数据视图，对数据列作索引；查询存储在数据表和数据视图中的数据；增删改数据行和增删改数据列本身；将数据库支持的 SQL 语句到数据库管理系统中进行数据查询。另外 SAS 也支持将 SQL 查询结果置入 SAS 宏变量中，进行数据传递功能。PROC SQL 功能非常强大，下面仅列出两个简单的例子：创建/查询数据表。

 

###### 1）  基于已有的数据集创建新的数据集，没有使用 DATA 步。

```
libname mylib 'c:\temp';
proc sql;
   create table mylib.myclass as
    select Name, Sex, Age, Height, Weight format=best.
      from sashelp.class;
proc print data=mylib.myclass; 
run;

```



###### 2）  使用标准的 SQL 语言创建数据集

如果 mylib 指向某个数据库管理系统，则会在该数据库中创建对应的数据表。

 ```
libname mylib 'c:\temp';
proc sql;
    create table mylib.myclass( Name char(8), Sex char(1), Age num, Height num, Weight numinformat=best. format=best.);
    insert into mylib.myclass
        values('Leon','M',31,175,80)
        values('Jim', 'M',30,173,75);

    title 'Table mylib.myclass';
    select * from mylib.myclass;

proc printto; run;
 ```



#### - SAS Step运行机制 

DATA 步的运行机制

 

前面的例子让我们看到SAS在处理数据非常方便，但这依然不够，我们需要深入探索SAS的DATA步是怎么工作的——即我们需要**深刻理解****SAS DATA** **步的运行机制**，这是SAS编程的核心内容之一。

首先需要指出的是，SAS语言是**按步进行编译执行**的，所以SAS程序与大多数编译型计算机语言程序一样，总体上要经过**编译和执行**两个阶段。简要流程如下图所示：

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/5af93309-5137-4b84-ab1b-0463cf2b7f72.png)](http://igeekbar.com/igeekbar/networks/uploadimg/5af93309-5137-4b84-ab1b-0463cf2b7f72.png)

**编译阶段**

 编译阶段SAS 主要做两件事：

1） 扫描DATA 步内的每一行语句，a) 执行语法检查：扫描代码片段，检查是否存在于语法错误。常见的语法错误包括**关键字缺失**或**拼写错误**、**无效变量名称**、**标点符缺失或者无效**、以及**无效的参数或选项**等。b)标识每一个变量的名称，类型和长度等信息，并且判断是否需要为后续变量引用作类型转换等。 

2） 为程序执行创建必要的数据结构，包括**输入缓冲区**IB(INPUT BUFFER)、**程序数据向量**PDV（Program Data Vector）和**输出数据集描述信息** DI(Descriptor Information),其中输入缓冲区 IB只在**从外部读取原始数据文件时**才是创建。

​	a)  **输入缓冲区****IB**：当DATA 步内执行INPUT语句是从原始数据文件（Raw Data，比如前面例子中的外部文本文件）中读取观测（记录）时，SAS会在内存中分配一块逻辑区域作为缓冲区，作为将数据放入PDV之前的临时缓冲区存在。如果是使用 SET语句来读取SAS数据集时，SAS则将数据直接拷贝到PDV中，而不需要所谓的输入缓冲区IB。

​	b)  **程序数据向量****PDV**：DATA步每读入一行数据时，都需要在内存中分配一个逻辑区域，用于存放数据集的变量和计算变量（即计算列）信息。其数据来自于输入缓冲区IB或SAS 执行语句。

另外，PDV中还包含2个仅用于系统处理阶段的临时变量，它们不会被写入目标数据集：

l  行计数器 **_N_**：用来对DATA 步的每次处理进行循环计数，从1开始；

l  错误标志 **_ERROR_**：用来标记执行过程中由于数据错误引起的错误；默认值是0，表示没有错误，否则为1，表示有一个或者多个错误。

​	c)  输出数据集描述符信息

SAS为每一个输出数据集创建和维护的元数据信息，包括数据集属性和变量属性。比如数据集名字，成员类型，创建日期，创建时间，观测数，变量名称，类型（字符型/数值型）等。

 

让我们考察如下代码的编译过程：

/*利用系统 SASHELP.CLASS数据，创建体质指数 BMI，俗称肥胖指数*/

 ```
data myclass;
  set sashelp.class;
  where age> 12 and sex='男';
  BMI=(weight * 0.4535924) / ((height*2.54/100) 2**);
  format BMI 4.1;
  drop weight height;
run;
 ```

对于如上代码，编译时 PDV 的变化依次如下图右侧所示。从上到下各行语句编译时会修改PDV，比如DROP 语句的作用是告诉SAS PDV中哪些变量不需要输出到输出数据集，对那些变量设置“删除”标志，以免执行时输出到目标数据集中。

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/90f97159-c139-4ff8-9bcf-8e316ec9de74.png)](http://igeekbar.com/igeekbar/networks/uploadimg/90f97159-c139-4ff8-9bcf-8e316ec9de74.png)

编译到 RUN 语句时，DATA步编译宣告结束。SAS会为需要输出到目标数据集的那些变量，创建必要的描述符信息——包括数据集中各列的名称、类型、长度、输出格式、标签等。

 

**运行阶段**

一旦编译成功，执行阶段开始。SAS 的执行主要有如下步骤：

1） SAS 首先会从DATA语句处开始执行，如果是第一次执行，SAS会设置内部变量_N_=1和_ERROR_=0，否则会对内部计数器 _N_自动加1。

2） SAS会以缺失值对**程序数据向量**（PDV）中那些由**INPUT****语句**和**赋值语句**创建的变量进行初始化。注意：那些以 SET, MERGE, MODIFY或 UPDATE语句读取的变量并不会被重置为缺失值。

3） 默认情况下，SAS从外部原始数据文件中**读入一条数据记录到输入缓冲区****IB**中，然后创建对应的PDV，或者直接从SAS数据集中**读入一个观测到程序数据向量****PDV**中。SAS语句 INPUT和 SET、 MERGE、 MODIFY、UPDATE都可以用来读入一条记录。

4） 对当前记录，执行后续的SAS程序语句，包括赋值、计算和更新等等。

5） 当执行到 DATA 步的最后时，隐含的SAS语句 OUTPUT，RETURN和RESET 自动触发。SAS将当前记录作为一个观测写入到SAS数据集中。执行自动返回到DATA 步的开始处进入下一循环。如果SAS 读取外部文件结束或SAS数据集结束，则整个 DATA 步执行终止，进入后续的DATA或PROC步的编译执行。

 

让我们考察前面代码的运行过程，其中DATA 步中的新变量（如体质指数BMI）首先也会以缺失值 . 进行初始化，随后在执行赋值语句时对表达式重新求值，赋给那些新变量；然后执行下一行语句…在 DATA 步的最后，SAS会将PDV中没有删除标志的非临时变量（除了 height, weight）和值写入到目标数据集中。然后控制流程再返回到 DATA 步的开始处进入下一个循环。正是**SAS DATA****步这种独特的隐性循环设计，为用户在进行数据处理时提供了自然的循环概念，从而让用户对具体文件的****I/O****读写细节不必过于关注。**

 

当SAS进入下一次循环时，临时变量 _N_ 计数器会自动加1，对于非INPUT语句读入的情况，SAS 也会保留上次读入到 PDV中的变量值，直到被新读入的观测所覆盖；对于DATA步中的新变量（如体质指数 BMI），SAS会重新使用缺失值 (.) 进行初始化。当数据被再次读入时（比如从上面的SET语句所指定的源），SAS会将源数据集中的第二个观测读入到 PDV中，并重新计算程序中的新变量 BMI。然后在DATA步的最后，使用 PDV中的值作为第二个观测（记录）写入到输出数据集中。然后控制再次回到DATA步开始，一直循环执行，直到源数据集中的所有观测都被处理完毕。

 

 

**结语**：本章我们学习了利用SAS创建数据集的几种灵活方法，然后介绍了SAS DATA 步运行机制的奥秘。深刻理解DATA步的编译运行机制对掌握SAS 编程至关重要，灵活使用SAS DATA 步可以为分析准备任何形式的待分析数据。

 下面笔者就以如何生成前20个黄金分割数列的简单SAS程序来结束本章的学习! 黄金分割数列即斐波那契数列，该数列中后一个数与前一个数的比例越往后越接近于黄金比例(1+√5)/2 ，此数列分布表现出极致的均衡与和谐之美；其前8个数为：1 1 2 3 5 8 13 21…

[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/b358e8df-0422-46eb-8aa9-89d851864b56.png)](http://igeekbar.com/igeekbar/networks/uploadimg/b358e8df-0422-46eb-8aa9-89d851864b56.png)[![img](http://igeekbar.com/igeekbar/networks/uploadimgthumb/0693a665-5785-4ad4-9876-33b8b3e961d6.png)](http://igeekbar.com/igeekbar/networks/uploadimg/0693a665-5785-4ad4-9876-33b8b3e961d6.png)

/*生成前20个黄金分割数列到数据集 WORK.FbNC 中*/

```
data Fbnc;
    do n=1 to 20;  
       if n=1 or n=2 then y=1;
       else y=  y1 + y2; y2=y1; y1=y; 
       output;
       put n= y=; /打印到SAS日志/
    end;
    drop n y1 y2;
run;

proc print data=fbnc;run;
```

输出：

n=0 y=1

n=1 y=1

n=2 y=2

n=3 y=3

n=4 y=5

n=5 y=8

n=6 y=13

n=7 y=21





## 07 - 常量与变量

认识世界的第一步是正确命名各种实体，在SAS 程序中，标识符是就是用于命名编程语言实体的名称。常用的标识符分为变量名和成员名两大类，包括常量名、变量名、数组名、函数名、逻辑库和文件引用名称，成员和数据集名称等等。标识符名称只能以**字母或下划线开头，由字母、下划线或者数字组成**。大部分标识符名称（比如**数据集名和变量名）**遵循**长度不得超过32字节**规则，除了：

 

**1.**  **逻辑库引用/文件引用**（libref/fileref）名称**最长为8字节**

**2.**  **函数**/**调用例程**（Function/CALL Routines）函数名**最长为16字节**

 

另外，关于长度限制还有如下一些特例：

- 格式名长度限制：字符/数值型输出格式名称最长为31/32字节；字符/数值型输入格式名称最长为30/31字节。
- 数据集描述标签最长为32字节，而数据列描述标签最长为256字节。

 

在下面的例子中，libref 标识符最长只能 8 个字节。而数据集（表）和变量（列）最长为 32 个字节。如果你增加一个字符则会报编译错。

 

libname **lib45678** "c:\temp";  /*逻辑库名最长８字节*/

 ```
data lib45678.tab45678901234567890123456789012;/*数据集名最长 32 */
    col45678901234567890123456789012=10; /*数据列（变量名）最长 32 */
    a_=10;
    _a=10; 
run;
 ```

在下面的例子中，fileref 标识符最长只能８个字符。样例代码演示了在如何将文本写入外部文件　c:\test.log。

 ```
/fileref 最长只能８字节/

filename file5678 'c:\test.log' encoding="utf-8";
data null; 
   file file5678;
   put "Hello World!";
run;
 ```

SAS 有两个系统选项可用于控制变量名和成员名的命名规则：

- VALIDVARNAME：指定SAS会话中可以创建和处理的有效的**SAS变量名**，有三个参数可选：**V7 | UPCASE | ANY**，默认值为上面讲到的传统命名规则 V7；UPCASE就是在V7命名规则之上，变量名还必须是大写的（用于早期SAS版本）；如果变量命名中要包含国家语言字符（如中文），必须指定为 ANY。用法如下：

 ```
options validvarname=ANY; 
 ```

即使启用了 ANY 变量命名规则，变量名仍然不能与系统自动变量 **_N_、_ERROR_** 或者系统变量列表 **_NUMERIC_****、_CHARACTER_** 和 **_ALL_** 相冲突。 

- VALIDMEMNAME：指定有效的SAS成员名，成员包括SAS数据集、SAS 数据视图、SAS 目录、SAS索引及 SAS Item stores 等。有2个参数可选：**COMPATIBLE** | EXTEND，默认值为 COMPATIBLE；如果成员命名中要包含国家语言字符（如中文）或除了 / \ * ? " < > | : - 之外的特殊字符，必须指定为 EXTEND。用法如下：

 ```
options validmemname=EXTEND;
 ```

如果启用了这种扩展的命名规则，我们就可以在 SAS 里使用非英文的标识符来命名数据集或者数据集中的变量（即列名）。另外即使启用了EXTEND成员命名规则，命名仍然不得以英文句号开头；对于SPDE引擎，其名则不得包含英文句号且不能以美元符 $ 开头。简单例子如下：

```
/逻辑库名最长８字节/
libname lib45678 "c:\temp";
/需要 options validmemname=extend; 否则编译错/
data lib45678."中央人民政府数据库"n; 
    /需要 options validvarname=any; 否则编译错/
"中央人民政府变量名"n=10;          
run;
proc contents;run;
```

你可以在 SAS 中使用如下语句查询特定系统选项的设置：

 ```
proc options option=(validvarname validmemname);
run;
 ```

#### - 常量与变量

 

在 SAS 语言DATA步中，可以在表达式中直接定义一个数值型或字符型常量。比如：

 

- 数值型：**255**，**3.1415926**，**1.25E-10**
- 字符型：'Hello World'，"HELLO WORLD"，"张三"

 

SAS 数值型变量和字符型变量**默认长度都是8个字节**，其中数值型变量可指定任何 **3-8 字节之间的任何长度**(Linux/Windows最小长度为3，而不常见的IBM z/OS 平台上最小为2字节)，而字符型则可指定 **1-32767 字节**的任何长度。**变量的类型和长度在SAS中可以使用下面三种方式之一**显式指定：**LENGTH 语句，ATTRIB 语句或者 FORMAT 语句(仅对字符型未指定长度时有效)**；其中 ATTRIB语句可以同时为多个变量指定类型和长度，而FORMAT则在指定类型和长度时也指定了输出格式信息。比如：

```
data MyData;
    /数值型 2-8/
    length n1 8;
    attrib n2 length=8;
    format n3 8.;
    /字符型 1-32767/
    length c1 $ 8;
    attrib c2 length=$8;
    format c3 $8.;
run;

proc contents;run;
```

SAS作为一种数据处理语言，需要经常处理没有观测到的数值，称为缺失值。数值型缺失值用单个**小数点符号 .** 表示，字符型缺失值使用**单个空格字符** 表示。

 ```
data null;
    missingnum=.;   *指定数值型缺失值;
    missingstr=' '; *指定字符型缺失值;
call missing(missingnum, missingstr);
*使用 CALL MISSING 例程来将变量设置为缺失值;
    nullstr="";      *对于字符型变量，传统的空字符也被当作缺失值看待;
    length dotstr $ 1; *对于字符型变量，赋给 . 等价于赋给 ".";
    dotstr=.;  dotstr2='.';
    if dotstr=dotstr2 then put "dotstr is equal to dotstr2";
    *检测变量是否为缺失值;
    if missingnum=. then put "missingnum is missing";
    if missingstr=' ' then put "missingstr is missing";
    if nullstr=' ' then put "** nullstr is missing";
   *使用函数来检查缺失值;
    if missing(missingnum) then put "missingnum is missing";
    if missing(missingstr) then put "missingstr is missing";   
    if missing(dotstr) then put "dotstr is missing";
run;
 ```

系统输出：

dotstr is equal to dotstr2

missingnum is missing

missingstr is missing

** nullstr is missing

missingnum is missing

missingstr is missing

 

###### 1) 数值常量

 

- 整数与双精度浮点数

 

数值型常量可以用**整数、定点实数以及科学计数法实数**表示。但在常量赋给某个变量的时候需要注意精度问题。默认情况下，没有精度丢失的最小和最大整数区间为十六位的整数：-9007199254740992 到9007199254740992（十六进制：FFE0000000000000 – 20000000000000），超过此范围的整数赋值可能精度丢失。

 你可以在机器上运行如下程序，对比不同的结果。

 ```
data null;  
    intc_min=-9007199254740992; intc_max= 9007199254740992; 
    put "Integer Constant: " intc_min 17.  " ~ " intc_max 17.;
    *区间内的数值;
    intc_min2= intc_min + 1; intc_max2= intc_max - 1; 
    put "Integer Constant: " intc_min2 17. " ~ " intc_max2 17.;   
    *区间外的数值:精度丢失...;
    intc_min2= intc_min - 1; intc_max2= intc_max + 1; 
    put "Integer Constant: " intc_min2 17. " ~ " intc_max2 17.;
    intc_min3=-9007199254740993; intc_max3= 9007199254740993; 
    put "Integer Constant: " intc_min3 17. " ~ " intc_max3 17.;
    *区间外的数值重新回到区间内;
    intc_min4= intc_min3+1; intc_max4= intc_max3-1; 
    put "Integer Constant: " intc_min4 17. " ~ " intc_max4 17.;
run;
 ```

系统输出：

Integer Constant: -9007199254740992 ~  9007199254740992

Integer Constant: -9007199254740991 ~  9007199254740991

Integer Constant: -9007199254740992 ~  9007199254740992

Integer Constant: -9007199254740992 ~  9007199254740992

Integer Constant: -9007199254740991 ~  9007199254740991

 

实数常量表达式支持**除小数点外的11位有效数字（包括符号位）**；如果用科学计数法表示（比如 *2.22507E-308*），除小数点外的整个数字（包括尾数、E、E后面的符号位、指数）的有效位为11位。SAS浮点数的表达范围为：2.22507E-308 到1.797693E308（HEX为 000FFFFE2E8159D1 到 7FEFFFFFD7B9609A）。

```
data null;  
    /定点实数表示: 结果只支持11位有效数字精度(不包括小数点)/
    x=123456789.012;            *结果是 123456789.01;
    y=0.12345678912;            *结果是 0.1234567891;
    put "X=" x  " Y=" y  ; 

    /科学计数法表示：SAS 浮点数最小/最大值，除小数点外最长只能有11位有效数字;/
    double_min= 2.22507E-308; 
    double_max= 1.797693E308; 
    put "double: " double_min  "~ " double_max ; 
    double1=double_min / 2000000; *等于0.00001E-309 约等于 0;
    double2=double_max + 1.0;      *表示超出范围，还是最大的浮点数;
    put "double1=" double1  "double2=" double2; 

    double1= 2.225071E-308;   *结果是 2.22507E-308;
    double2= 1.7976931E308;   *结果是 1.797693E308;  
    put "double1=" double1  "double2=" double2;
run;
```



- 日期/时间/日期时间

日期/时间/日期时间类型是一种特殊的**数值型**，其常量定义采用引号后面加d、t或dt来分别表示（大小写均可）。SAS的日期时间数据定义与别的公司不同。比如：SAS 对 DateTime的定义是从公历**1960年1月1日00:00:00开始的秒数**。而微软对于 DateTime 的定义则是从公历**0001年1月1日00:00:00开始的滴答数**（Ticks：一秒钟等于1千万个滴答数） 

下面的例子演示了如何利用日期常量，时间常量以及日期时间常量对变量进行赋值：

 ```
data null;
    d='02JAN1960'D;
    t='00:00:01'T;
    dt='01JAN1960 00:00:01'dt;
 
    put " d=" d date.;
    put " t=" t time.;
    put "dt=" dt datetime.;
 
    put "value=" d t dt;
run;
 ```

运行上面的代码，结果你会发现变量 d、t和dt 不指定格式时的输出值都等于1，但他们的语义不同：d 是1960年1月2日，t是 00:00:01，而 dt 是1960年1月1日凌晨 00:00:01。

 

在 SAS 系统中，还可以使用** CONSTANT函数**来返回数学常量，比如 PI值, E值, EULER欧拉常数等，但一般不推荐大量重复调用 CONSTANT函数来获得常数给变量赋值。

 ```
data null;
    pi=CONSTANT("PI");
    e=CONSTANT("E");
    euler=CONSTANT('EULER'); 

    put "PI=" pi;
    put "E=" e;
    put "EULER=" euler; 

    small=CONSTANT('SMALL');
    big=CONSTANT('BIG');       
    put "Double:" small "-" big;
run;
 ```

其中 SMALL和 BIG 分别返回当前机器上8字节所能表达的最小/最大双精度浮点数，即SAS 所能表示的双精度数范围的最小和最大值：**2.22507E-308** 和**1.797693E308**。上面代码的输出为：

 

PI=3.1415926536

E=2.7182818285

EULER=0.5772156649

Double:2.22507E-308 -1.797693E308

 

###### 2)  字符常量

字符常量需要使用**单引号或者双引号**括起来，两者的区别是**单引号字符串不会进行宏展开**，而**双引号中的字符串则会进行宏展开**。比如：

 ```
data null;
    c="&sysver";
    put "SAS Version is " c;

    c2='&sysver'
    put "SAS Version is " c2;  
run;
 ```

输出结果为：

 

SAS Version is 9.3

SAS Version is &sysver

 

注意：在 SAS 里，如果变量名字**包含空格或者国家语言特定的字符**，我们可以使用Name Literal来命名。其形式是一个引号括起来的**空格或者国家语言字符**的字符串常量，**引号后面加上n**（大小写皆可）。这种特殊的变量命名通常用于*关系数据库的表名/列名*、*SAS 变量名*、*语句标签* （需要启用系统选项 VALIDVARNAME=ANY）；或者*SAS数据集*、*SAS数据视图*和*Item Store* （需要启用系统选项 VALIDMEMNAME=EXTEND）的命名中，用于和外部系统交互而设计的。

 

*Name Literal 如果包含空格和国家语言字符，需要启用系统选项VALIDVARNAME=ANY;

*否则会报告语法错误;

```
options validvarname=ANY;
data null;  
    pi=3.1415926;
    c="PI"; c2="pi"n;
    put  c "=" c2;
    "var 1"n = 100;
    put "var 1=" "var 1"n; 
    "变量1"n = 100;
    put "变量1=" "变量1"n; 
run;
```

系统输出如下：

PI =3.1415926

var 1=100

变量1=100

 

**结语：**任何编程都是从常量和变量开始，构建复杂的程序表达世界。SAS与传统编程语言不同之处在于为数据分析从根上定义了面向分析的数据类型和表达方式，从而注定了SAS编程人员的视角是基于一种更加高级、面向信息的数据表达，而不是传统的基于字节和位操作之上的数据结构和算法体系，尽管SAS依然保留了对字节和位层次的操作能力！



## 08 - 表达式

SAS 表达式（SAS Expression）是SAS 语句的组成部分，是构成SAS程序指令集合的**一系列操作数和运算符的集合**。操作数包括常量和变量，运算符则包括**算术运算**、**关系运算**、**逻辑运算**等运算类型。SAS表达式也包括**赋值运算**以及一些SAS特有的运算类型。SAS 默认不支持位运算，但可以利用变通的方法实现。

 #### - 算术运算符

用于数值常量或变量进行算术运算，包括加法 +、 减法 -、 乘法 *、 除法 / 和乘方 ** 。 运算符的优先顺序为：乘方优先，先乘除后加减。

| 运算符 | +    | -    | *    | /    | **   |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 释  义 | 加   | 减   | 乘   | 除   | 乘方 |

 ```
data null; 
    a= 3; b=4; c=5; d=6;
    d = a + b;
    e = a * b;
    f = a / b;
    g = a ** 2;  
    h = a + b  * c  / 6;
    i =(a + b) * c  / 6;

    put "d=" d "e=" e "f=" f "g=" g "h=" h "i=" i;
run; 
 ```

​         输出结果为：d=7 e=12 f=0.75 g=9 h=6.3333333333 i=5.8333333333

 

#### - 关系运算符

用于比较常量或变量（数值型或字符型）的大小。关系运算符包括：

| 运算符 | **=**  | **^=** | >      | <      | >=     | <=     |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 释  义 | 等于   | 不等于 | 大于   | 小于   | 大等于 | 小等于 |
| 别  名 | **EQ** | **NE** | **GT** | **LT** | **GE** | **LE** |
| 变  体 |        | **~=** |        |        | **=>** | **=<** |

 其中运算符 EQ、NE、GT、LT、GE、LE为对应运算符的别名，数值型基于数值大小比较，而字符型基于从前到后字符的码点值大小进行比较；SAS中缺失值和空格字符在比较运算中比任何可打印字符都小。为了和早期版本兼容，SAS不等于运算符 ^= 也可以写作 ~= ，而小等于<= 和大等于 >= 也可以写作 =< 和 =>。比如：

 ```
data null; 
    a= 3; b=4; c=5; d=6;
    e=(a ^= b); f=(a ~=b );
    put "(a^=b)=" e "(a~=b)=" f;
    g=(a => b); h=(a =< b );
    put "(a=>b)=" g "(a=<b)=" h;
run;
 ```

输出结果为：

 (a^=b)=1 (a~=b)=1

(a=>b)=0 (a=<b)=1

 

**注意：与传统的C****或C++** **的等于/****不等于运算符（==** **和 !=****）不同，SAS****采用单字符 =** **和 ^=** **来表示**。SAS也为一些列的操作符提供了别名功能。

 

SAS语言还有自己特殊的关系表达式写法，比如SAS可以把变量写在中间，变量前后都是运算符和操作数。比如： **op1 <= var1 <= op3***，*其对应的别名写法就是 *var1 \**BETWEEN** op1 **AND**op3**，*表示 var1介于op1 和 op3 之间。

 

#### - 逻辑运算符

用于表达式中的逻辑（布尔）运算，包括

| 运算符 | &    | \|     | ^    |
| ------ | ---- | ------ | ---- |
| 别  名 | AND  | OR     | NOT  |
| 释  义 | 与   | 或     | 非   |
| 变  体 |      | ¦ 或 ! | ~    |

 在计算机术语中，FALSE表示0，而TRUE 表示1。在SAS 程序中，**0** 或 **缺失值** 视为 FASLE，而将任何 **非****0****值** 或 **非缺失值** 视为真。因此SAS 程序中单个数值变量也是可以参与逻辑运算的。

```
data null; 
    a= 3; b=4; c=5; d=6;

    e =(a<b)|(c>d);
    e2=(a<b)¦(c>d);  e3=(a<b)!(c>d);

    f= (a<b) & (c>d);
    g=^(a<b);

    put "or=" e "and=" f "not=" g;
    put "or=" e2 "or=" e3;
run;
```

​    输出结果为：

or=1 and=0 not=0

or=1 or=1

 

**注意：与传统的C****或C++** **的逻辑运算符与（&&****）、或（||****）、非（！）不同，SAS****采用单字符& | ^** **来表示；**SAS中* || 表示字符串拼接操作*。

 

#### - 特殊运算符

除了上面的运算符，SAS 语言还有一些其他语言没有的特殊运算符，主要包括：

| 运算符 | **<>**   | **IN** | **\|\|**                            |
| ------ | -------- | ------ | ----------------------------------- |
| 释  义 | 取最大值 | 属于   | 字符串拼接                          |
| 运算符 | **><**   |        | **LIKE**                            |
| 释  义 | 取最小值 |        | 字符串通配符：%任意字符，- 单个字符 |

 

**取最大值/****最小值预算符**（<> 和 ><）：相当于 MAX/MIN函数，但在SAS中被作为一种运算符存在。如果缺失值是比较运算的一部分，SAS会用缺失值的排序顺序进行比较，比如 .A <> .Z 返回 .Z

 

**集合运算符****IN** 是SAS语言特有的运算符，用于**检查变量的值是否在一个给定的列表**中。列表内必须为常量、缺失值或枚举器 Iterator。比如 *Name IN (“Alfred**”, “Alice”**)**。*

```
data null; 
    a= 3; b=4; c=5; d=6;
    c=(a<b); d=(a=b); e= a IN (**3** , 4**,** 5 );
    put "(a<b)=" c "(a=b)=" d "e=" e;
run;
```

 

输出结果为： (a<b)=1 (a=b)=0 e=1

 

**字符拼接运算符 ||** 用于连接两个字符型变量或常量，它并不删除前一个字符串的尾部的空格，因此我们需要使用 **TRIM函数删除尾部空格来达到预期效果**，比如：TRIM(var1) || var2 。

 ```
data null; 
    max= 3**<>5**;
    min= 3**><5**;
    
    ab= 'a'||'b';
    put "Max=" max "Min=" min "'a'||'b'=" ab;
    
    length var1 **8** var2 8;
     var1='hello'; var2='kitty';
     var3=var1 || var2;
     put "var3=" var3;
     
     var4=TRIM(var1) || var2;
     put "var4=" var4;
run;
 ```

输出结果为：

Max=5 Min=3 'a'||'b'=ab

var3=hello   kitty

var4=hellokitty

 

**字符串通配符比较 LIKE** 用来在一些表达式中模糊匹配字符串，比如WHERE 语句中的 LIKE 字符串比较。其中百分号** % 表示任意字符，下划线 _ 表示单个字符**。

 ```
data myclass;
    set sashelp.class;
    where Name like "%丽%";
run;
proc print;
run;
 ```

输出如下：[![img](http://www.igeekbar.com/igeekbar/networks/uploadimgthumb/58684d29-757b-4a99-95b8-a93be2a0c944.jpg)](http://www.igeekbar.com/igeekbar/networks/uploadimg/58684d29-757b-4a99-95b8-a93be2a0c944.jpg)

```
data myclass;
    set sashelp.class;
    where Name like "_丽";
run;
proc print;
run;
```

**         输出如下：

[![img](http://www.igeekbar.com/igeekbar/networks/uploadimgthumb/f93c6c9e-2aeb-49b3-9053-03c2704aa3b7.jpg)](http://www.igeekbar.com/igeekbar/networks/uploadimg/f93c6c9e-2aeb-49b3-9053-03c2704aa3b7.jpg)

 

**注意：在WHERE** **语句中运算符 IS MISSING** **和 IS NULL**可分别用来判断变量是否为缺失值或空值，等价于 var=. 和 var=’’ 关系运算符。

 

#### - 运算符优先顺序

 

当一个表达式包含多个运算符，且没有使用括号来显式分割子表达式时，就会涉及到运算符优先顺序问题，总体上：

 

首先，与其他计算机语言一样，表达式中的括号 () 具有最高优先级，用户也可以使用括号来人为分隔表达式指定结合顺序，避免潜在的歧义性。

 

其次，乘方运算 ** 和取正负号的单目运算符 + 和 – 为第二优先级；然后才是算术运算，关系运算和逻辑运算。

 

另外，取最大/小值操作符 <> 和 ><仅次于乘方运算 **，但优先于取正负号运算。字符运算符 || 和集合运算符 IN优先于关系运算符，但比算术运算符优先级低。

 

下表为SAS运算符优先顺序表：

 

| **优先级** | **运算符**        | **类别**        | **释义**                                             |
| ---------- | ----------------- | --------------- | ---------------------------------------------------- |
| 1          | ()                |                 | 括号中的表达式最先求值                               |
| 2          | **                |                 | *乘\**方运算***                                      |
|            | **<>  ><**        | **SAS****特定** | **取最大值、最小值运算**                             |
| 3          | **+ -**           | 单目运算        | **取正/****负号**                                    |
| 4          | * /               | 算术运算        | 乘除法                                               |
| 5          | + -               | 算术运算        | 加减法                                               |
|            | **\|\|**          | **SAS****特定** | **字符串拼接**                                       |
|            | **IN**            | **SAS****特定** | **集合包含运算**                                     |
| 6          | =  <>  >  <>=  <= | 关系运算        | 比较运算符：等于、不等于，大于，小于，大等于，小等于 |
| 7          | **^**  &  \|      | 逻辑运算        | 优先级为 **NOT** AND OR, 从左到右结合                |
| 8          | =                 |                 | 赋值运算符                                           |

 SAS表达式中**乘方、取正负号运算符、逻辑非、取最大/小值等6种运算符（红色）为第一优先级且**从右到左**进行求值，其他的运算符都是**从左到右进行求值**。实践中鼓励大家明确使用括号来分隔表达式，或者将一个复杂表达式分解为多个赋值语句来提高代码的可读性！

 

#### - SAS赋值语句

 赋值语句用来**对一个表达式进行求值，然后把结果赋给一个变量**（新的或者已有的）。 赋值语句是**极少数不需要以关键字开始的****SAS** **语句**。

```
var1 = Expression;
```

等号前后分别为变量名和表达式。**右侧表达式在求值时，需要根据前面的运算符优先顺序进行求值**。**如果右侧表达式中包含缺失值，则计算的结果为一个缺失值**。

 当表达式右侧包含左侧变量时，变量首先会在求值过程中被使用，最后将结果存储在左侧的变量中。考察如下代码：

 ```
data null;
    a=a+1;
    b=3; b=b+1;
    put a= b=;
run;
 ```

系统不会输出a=1，而是输出a等于缺失值：a=.，原因是a在右侧被使用的时候为缺失值，而表达式中包含缺失值则计算结果为缺失值。对于程序b则会输出 b=4.

 

#### - SAS累加赋值语句

 

SAS 步中还有一个很特殊的变量**累加赋值语句**,它没有关键字也不需要等号，它是极少数不需要关键字开始的SAS语句之一。其形式为：

 ```
 var+Expression
 ```

其中 var 被隐含为数值型变量，SAS会将它初始化为0，然后在DATA步循环中不断将表达式求值，然后赋给该变量。另外，该变量在DATA步循环中也不会被清零，就像有 RETAIN语句作用于该变量一样。考察如下代码：

 ```
data null;
    set sashelp.class;
    c+1; /奇葩代码有木有…但得承认它很简洁/
    put c=;
run;
 ```

系统输出 c=1 c=2 … c=19。该语句等价于 retain c **0**; 和 c=sum(c,**1**); 语句。

 ```
data null;
    set sashelp.class;
    retain c 0; c=sum(c,1); /介个代码才比较像人话/
    put c=;
run;
 ```

缺省地，累加赋值语句初始值为 0 开始，我们可指定其初始值，比如下面的代码会输出 c=101 c=102 … c=119。

 ```
data null;
    set sashelp.class;
    retain c 100; /指定初始值/
    c+1;
    put c=;
run;
 ```

#### - RETAIN语句

RETAIN语句可以让 **INPUT** **语句或赋值语句创建的变量**在DATA步隐性循环中得以保持，避免被用缺失值重新初始化。它是申明性语句，并非执行性语句。其基本形式为：

 *retain* *var1 … varN value1 … valueN;*

其中变量列表可以是系统预定义的列表 _ALL_，_NUMERIC_或者 _CHAR_，分别表示全部变量，全部数值型变量或字符型变量。另外，如果一个变量仅仅出现在 RETAIN 语句中却从未被赋值，该变量是不会被输出到输出数据集的。

 

**注意：RETAIN 语句用来指定在DATA步循环中不要重新初始化为缺失值的那些变量；而KEEP 语句用来指定需要输出到目标数据集中的那些变量，与之相对应的语句是 DROP语句。**

 

比如下面的代码，我们可以对 sashelp.class 的所有年龄求和，考察如下代码你会发现 total 能得到正确值，而total2 只有第一个观测有值，其他都是缺失值。

```
data null;
    set myclass;
    retain total 0; /初始化为 0/
    total=total+ Age;
 
    if N=1 then total2=0;/初始化为 0/
    total2=total2+Age;
 
    put age= total= total2=;
run;
```

系统输出：

Age=14 total=14 total2=14

Age=13 total=27 total2=.

Age=13 total=40 total2=.

Age=16 total=56 total2=.

Age=14 total=70 total2=.

Age=12 total=82 total2=.

Age=13 total=95 total2=.

Age=14 total=109 total2=.

Age=12 total=121 total2=.

Age=15 total=136 total2=.

Age=12 total=148 total2=.

Age=15 total=163 total2=.

Age=11 total=174 total2=.

Age=11 total=185 total2=.

Age=15 total=200 total2=.

Age=15 total=215 total2=.

Age=12 total=227 total2=.

Age=12 total=239 total2=.

Age=14 total=253 total2=.

 

在DATA 步中，**有些变量默认具有保持特性**，它们不需要额外的 RETAIN 语句进行指定。当然，除了 _N_ 和 _ERROR_ 外，我们可以为任何变量使用 RETAIN语句来指定初始值。默认具有RETAIN保持特性的变量如下：

 

1)         自动变量 _N_, _ERROR_ 以及 _I_, _CMD_ 和 _MSG_

2)         SAS语句 SET, MERGE, MODIFY 或 UPDATE 语句中读入的变量，或这些语句中使用END= 和 IN= 选项创建的变量

3)         SAS语句 FILE, INFILE语句中使用 BY= 选项创建的变量

4)         累加求和变量

5)         临时数组中指定的数据元素

6)         SAS语句ARRAY 中初始化的数组元素、或者这些数组元素的数组元素。

 

当我们需要对数据集中的观测进行遍历时，我们经常会用到 retain 语句。灵活应用它配合隐性循环可以完成一些复杂的功能。比如下面的例子查找 sashelp.class 中男生和女生中的最矮身高。

 ```
proc sort data=sashelp.class out=temp;
   by sex;
run;

data myclass;  
   set temp;
   retain Shortest; 
   by sex;
   if first.sex then Shortest=height;     
   Shortest=Shortest><height;
   if last.sex then output;
    keep sex Shortest;  
run;

proc print data= myclass; run;
 ```

系统输出：

​    [![img](http://www.igeekbar.com/igeekbar/networks/uploadimgthumb/a44d4dd1-c44b-4ff6-9261-8ffc1e258d6c.jpg)](http://www.igeekbar.com/igeekbar/networks/uploadimg/a44d4dd1-c44b-4ff6-9261-8ffc1e258d6c.jpg)

 

结语：表达式是构成语句的基础，而语句则是构成程序的基础。就像我们说话的时候会分成段落、句子一样，表达式是我们完整句子里的每一个片段。良好的表达式应该是具有非常清晰的变量/常量命名，而且表达式中的运算关系非常明确，没有歧义易于维护的语句片段！







## 09 - 数组

SAS 数组与传统编程语言不同，它并非一种特殊的数据结构，而是一种变量的组织引用方式。SAS 数组本质上是对 SAS 变量的临时分组。**SAS 数组名甚至不是一个变量，只是提供对一系列变量进行统一引用的名称**而已。

SAS 数组使用 ARRAY 语句进行定义，默认情况下数组名称、数组长度和构成数组元素的变量列表是必需的部分，但临时数组则不需要定义元素变量列表。其他部分则是可选的。其完整语法为：

**array****数组名称** **[****数组长度****]** *<$> <元素长度>***变量列表***<(**初始值**…)>;*

- **数组名称：**任何有效的 SAS 名称, 最大长度为32字符。
- **数组长度：**数组中的元素个数。
- **元素类型：$：**表示数组元素是字符型，如果没有 $ 符号，表示数组元素为数值型。
- **元素长度：**数组中元素的共同长度。
- **元素变量列表：**构成数组的变量列表，通常用 var1 - varN 形式定义。
- **元素初值列表：**依次定义数组元素的初始值。

**注意：**上面可以看出，SAS 数组的最大长度和数据集的最大列数相关；在 SAS 9.1 以前最大列数为32767，在更高的版本中则取决 SAS 运行环境和文件属性（最大变量数取决于所有变量字节长度的总和，且不得超过操作系统的最大页面大小）。笔者就曾试验过400万列的 SAS 数据。

最常见的定义方式如下，数组元素不仅能够定义类型，也可指定元素的长度，比如：

```
datanull;
arrayarray_n [3]; /定义了一个具有 3 个元素的数组，元素类型缺省为数值型/
arrayarray_c [3] $; /定义了一个具有 3 个元素的数组，元素类型为字符型/
arrayarray_cx [3] $ 2; /不但可以指定元素的类型，也可指定长度 2 个字符/
run;
```

下面的代码分别定义了若干3个元素的数值型/字符型数组，系统会默认生成一系列变量 array_n1，array_n2，array_n3，array_c1, array_c2, array_c3 等。

```
datanull;
arrayarray_n [3];
array_n[1]=1;array_n[2]=2;array_n[3]=3;
arrayarray_c [3] $;
array_c[1]='a'; array_c[2]='b'; array_c[3]='c';
/系统会默认生成一系列的变量 array_n1...因此下面也能正确工作/

putarray_n1= array_c1=;
arrayarray_cx [3] $ 2;/定义为字符型，宽度为2/
array_cx[1]='ABC'; array_cx[2]='BC'; array_cx[3]='CD';
putarray_cx[1]=; /长度发生截断，输出 AB/
run;

```

与传统的 C/C++ 语言不同，我们也可以人为指定数组元素变量的名字，比如：

```
arraymyarray [3] var1-var3;
/系统默认为 myarray[1]… myarray[3] 生成变量var1 … var3/
```



当然，我们指定的数组长度 3 必须与后面指定的维定义变量列表 var1-var3 的元素数量匹配，否则会报语法错误：

ERROR: 为数组myarray 指定的维定义的变量过多。

ERROR: 为数组myarray 指定的维定义的变量过少。



既然我们已经在变量列表 var1-var3 指定了数组长度为3，我们就可以**不显式指定数组长度了，而是使用 \* 来指定、或者忽略掉数组长度定义：**

```
arraymyarray1 [*] var1-var3;
arraymyarray2 var1-var3;
```



**注意：**虽然上面的代码创建了2个数组 myarray1 和 myarray2，其实他们对应的变量都是 var1,var2 和 var3。这体现了 SAS **数组是变量的组织方式**这一本质。



在数组元素变量列表后，我们也可以指定数组的初始值。比如：

```
arraymyarray[3] $ 4var1-var3 ('ABCD','BCDE','CDEF');
```

**注****意：C/C++ 使用大括号 {} 来包含数组元素，而 SAS 使用 () 来初始化数组元素。**



为了理解 SAS 数组的运行机制，请运行如下代码：

```
datamydata;
arraymyarray[3] $ 4var1-var3 ('ABCD','BCDE','CDEF');
putmyarray[1];
var1="12345";putmyarray[1];
myarray[1]="DEFG";putvar1;
run;
```



**系统输出：**

ABCD

1234

DEFG

上面的结果可以看出，SAS 数组只不过提供了对变量的另一种引用方式，var1 和 myarray[1] 是等价的。



#### - 数组名称

一个 SAS 数组**必须先定义后使用**，而且数组**只能在当前 DATA 步内**有效。数组命名必须遵循如下规则：

- 数组名必须**遵循 SAS 变量名命名规****则**，且**最长不得超过32个字符**。
- 数组名不得与同一 DATA 步内的其他任何变量名冲突。
- 数组名应避免与 SAS 系统函数/用户自定义函数重名；否则该名称会被优先当作数组名处理，从而阻碍了用户本来期望的函数调用。
- 数组定义和引用可以使用方括号[] 、也可使用括号 () 或者大括号 {}；由于大括号 {} 在其他 SAS 语法元素中不使用，官方推荐使用 {}。但笔者建议还是使用 C/C++ 等各种计算机语言广泛采纳的中括号 [] 。



#### - 数组元素变量列表

在定义数组元素变量列表时，可用以下3个之一的特殊变量来将 PDV 中的一系列变量组织到数组定义中。

- _NUMERIC_ 将所有的数值型变量当作该数组的元素
- _CHARACTER_ 将所有的字符型变量当作该数组的元素
- _ALL_ 将所有变量当作该数组的元素

比如：

```
datanull;
setsashelp.class;
arrayarray_c [*] CHARACTER;
putarray_c[1] "= "array_c[2];
run;
```

**系统输出：**

Alfred = M

Alice = F

… …

William = M



#### - 数组长度

数组长度是指数组中的元素个数，其下标可以是整型数值、返回整型数值的表达式、或者 * 号。数组长度必须被被 [] 或者() 或 {} 括起来。

注意：数组最大长度不是32767，而是取决于 SAS 运行环境的内存。笔者在自己的环境上尝试过2^22-1 (4194303 约400万) 没有任何问题，而2^23-1 (8388607 约800万) 时仍然只报告系统内存不足，没有任何语法错误。

**数组下标默认是从 1 开始的，而不像 C/C++ 或 Java 是从0开始的。可以使用系统函数 DIM 来返回数组的长度：**

```
doi = 1toDIM(myarray);
putmyarray{i};
end;
```

用户可以自定义下标区间，但一般情况下下我们推荐使用自然索引。

```
arraymyarray [2:4] $ 4var2-var4 ('ABCD','BCDE','CDEF');
```

通过运行如下代码，可以看到数组在程序数据向量（PDV）中的情况：

```
datamydata;
arraymyarray [2:4] $ 4var2-var4 ('ABCD','BCDE','CDEF');
put_all_;
run;
```

**系统输出：**

var2=ABCD var3=BCDE var4=CDEF _ERROR_=0 _N_=1



#### - 隐式数组下标变量

在定义数组长度时除了使用常量、返回常量的表达式、常量区间以及星号 * 外，我们也可以指定一个变量，称为下标变量。这种方式**只能使用括号来定义数组下标变量**，而且**数组只能被该下标变量进行引用、或者使用 DO-OVER 语句来引用**。其格式如下：

``` 
array数组名称 (**索引变量名)**<$> <元素长度> 变量列表<(初始值)>;
```

比如下面的代码：

```
datanull;
/如果指定 i 作为下标变量/
arraymyarray (i) $ x1-x3 ('ABCD','BCDE','CDEF');
put myarray[1]=;/显式下标索引不再可用*/
/我们只能使用该变量 i 作为索引，如果使用其他的 i 都会报告错误/
doi=1to3;
puti myarray;
end;
/也可完全使用隐性方式/
doovermyarray;
puti myarray;
end;
run;
```

**系统输出：**

1 ABCD

2 BCDE

3 CDEF

1 ABCD

2 BCDE

3 CDEF

**注意：**这种数组引用方式是 SAS 早期版本支持隐含数组定义的一种方式，现在已经不太推荐使用，但 SAS 代码为了向下兼容保留了该语法。



#### - 多维数组

如果数组有2个以上的维度，我们称为多维数组，其定义形式如下：

```
arraymyarray [数组长度1, 数组长度2] x1-x4y4-y4;
```

比如一个产品销售历史情况表：

![img](http://img.mp.itc.cn/upload/20170319/d32cc30b4ad64d5ea500ca373c6b0c46.jpeg)

定义一个2行X 4列的二维数组：

```
arraymyarray [2, 4] FURNITURE 1-FURNITURE 4 OFFICE1-OFFICE4;
```

然后可以按照 myarray [1,3] 方式引用数组元素，比如第1行第3列的3000 ：

完整的代码如下：

```
datamydata;
arraymyarray {2, 4}FURNITURE1-FURNITURE4
OFFICE1-OFFICE4
(1000, 2000, 3000, 4000,
1500, 2500, 3500, 4500);
i=1;
dowhile(i<=2);
put"Row:"i;
j=1;
dowhile(j<=4);
put"["i ","j "]="myarray[i,j];
j=j+1;
end;
i=i+1;
end;
dropi j;
run;
```



**系统输出：**

Row:1

[1 ,1 ]=1000

[1 ,2 ]=2000

[1 ,3 ]=3000

[1 ,4 ]=4000

Row:2

[2 ,1 ]=1500

[2 ,2 ]=2500

[2 ,3 ]=3500

[2 ,4 ]=4500

**注意：**尽管 SAS 提供了多维数组引用方法，但在 PDV 层面依然是用一维进行存储（如下图），

![img](http://img.mp.itc.cn/upload/20170319/a6f2f96c573346c0837c19be2a3a3fc3_th.png)

因此使用 PROC PRINT ，系统也只会打印出构成数组的变量名，而不是二维排列的数组元素。



#### - 临时数组

如果定义数组时使用关键字_TEMPORARY_ 进行修饰，则该数组为一个临时数组。临时数组只在定义数组的那个 DATA 步的执行期间存活，适用于存储计算的中间结果。临时数组不需要 **数组元素变量列表**来标识每一个数组元素。如：

```
arrayarray_n(3) temporary(0.05**0.080.12**);
arrayarray_c(3) $ temporary('ABCD''BCDE''CDEF');
```

临时数组与非临时数组行为几乎相同，但临时数组的“临时” 体现在如下几点：

- 临时数组元素**不会被输出到输出数据集**中，且在 DATA 步循环时**自动保留**。
- 临时数组元素没有名称，**只能通过临时数组名进行引用**。
- 临时数组定义必须**显式指定数组元素的个数或者索引区间**，不能使用 * 号指定长度。

临时数组可以用来扩展分支结构，在简化 SAS 代码时非常有效，比如分支结构：

ifindex eq **1**thenamount = amount * (**1**+ **0.05**);

elseifindex eq **2**thenamount = amount * (**1**+ **0.10**);

elseifindex eq **3**thenamount = amount * (**1**+ **0.15**);

elseifindex eq **4**thenamount = amount * (**1**+ **0.20**);

可以简化为：

```
datanull;
retainamount 1;
inputindex @@;
arrayrate [4] temporary(0.05**0.100.150.20**);
ifindex ge 1and index le 4then
amount = amount * (1+ rate{ index });
putindex amount;
datalines;
1 2 3 4
;
run;
```



**系统输出：**

1 1.05

2 1.155

3 1.32825

4 1.5939

由于临时数组经常用于计算或数据变换之用，所以经常与循环语句结合使用来初始化，比如：

```
datanull;
arrayv [3] temporary;
doi = 1to3;
v[i] = i ;
end;
run;

```



####　- 数组排序

SAS 提供 SORTN/SORTC 例程来对数组进行排序，**其中 SORTN 用于数值型变量，SORTC 用于字符型变量**。

考察如下代码，你会发现一旦调用排序代码，PDV 中的值（即数组中的值）会按照指定顺序重排，从而引用同样位置的数组元素将获得不同的结果值。

```
dataMyData;
x1=0.3; x2=0.1; x3=0.2;
y1="BCDE";y2="ABCD"; y3="CDEF";
run;
dataMyData;
arrayarray_n{3} x1-x3;
arrayarray_c{3} $ y1-y3;
setMyData;
put"Before: "array_n[1] array_n[2] array_n[3] ;
callsortn( of x1-x3);
put"After: "array_n[1] array_n[2] array_n[3] ;
put"Before: "array_c[1] array_c[2] array_c[3] ;
callsortc( of y1-y3);
put"After: "array_c[1] array_c[2] array_c[3] ;
run;
```

**系统输出：**

Before: 0.3 0.1 0.2

After: 0.1 0.2 0.3

Before: BCDE ABCD CDEF

After: ABCD BCDE CDEF



**注意事项**

SAS 数组结合 SAS 的循环语句在设计一些复杂算法的时候非常有用，能极大地提高编程效率。并且在 SAS 语言中，**SAS 数组中的变量其实并不需要有什么真正的相关性，所以使用起来非常方便。**当然，由于 SAS 数组与其他语言不同，使用过程中也很容易发生如下几种类型的错误：



- **引用未申明的数组错误：**当试图在一个数据步中，对另一个数据步内定义的数组执行运算时，编译会报如下错误：

ERROR: 引用了未声明的数组: y。

ERROR: 变量y 没有声明为数组。

考察如下代码：

````
datamydata;
arrayy [3] (100,200,300);
i = 1;
dowhile(i < 4);
put"y[ "i "]= "y[i] ;
i=i+1;
end;
dropi;
run;
/如下代码试图对数组 y 进行求和，然并卵/
datamydata;
sum=0;
i = 1;
dowhile(i < 4);
sum=sum+ y[i];
i=i+1;
end;
dropi;
run;
````



**解决方法1：**是可以利用 SET 语句在对单个数据集之上不断叠加运算。比如：

```
datamydata;
setmydata;
arrayy [3] y1-y3 ;
sum=0;
i = 1;
dowhile(i < 4);
sum=sum+ y[i];
i=i+1;
end;
dropi;
run;
proc**printdata=mydata; run**;
```

![img](http://img.mp.itc.cn/upload/20170319/be3367ab85044efba26c582f7af96765.png)

**解决方法2：**如果可能，我们也可以把数组的运算逻辑封装在同一个数据步内，比如：

```
datamydata;
arrayy [3] y1-y3 (100,200,300);
i = 1;
dowhile(i < 4);
put"y[ "i "]"y[i] ;
i=i+1;
end;
dropi;
/运算逻辑2/
sum=0;
i = 1;
dowhile(i < 4);
sum=sum+ y[i];
i=i+1;
end;
dropi;
run;
```

- **数组下标越界错误：**当数组下标不在数组定义的合法下标范围内时引发，包括低于下界或者高于上界。也有时候是因为使用 DO UNTIL 循环条件不当造成。

```
datamydata;
arrayy [3] (100,200,300);
i = 1;
dowhile(i <=4);/*或 do until (i >4); */
put"y[ "i "]= "y[i] ; /最后一个出错/
i=i+1;
end;
dropi;
run;
datamydata;
arrayy [2:4] (100,200,300);
i = 1;
dowhile(i <=4);
put"y[ "i "]= "y[i] ; /第一个出错/
i=i+1;
end;
dropi;
run;
```

- **指定的数组下标过多错误：**当数组名与函数名冲突时，SAS 会将该名称之后的括号按数组引用而非函数引用处理。换一句话说，就是 SAS 数组的命名不得与 SAS 系统函数或者用户自定义函数同名，否则会将函数调用给“拦截”，函数参数被当作数组下标处理而引发各种错误。

```
datamydata;
arrayy [3] (100,200, 300);
avg= mean(of y1-y3) ;
putavg=; /输出：avg=200/
run;

/正常输出数组 mean/

datamydata;
arraymean [3] (100,200, 300);
i = 1;
dowhile(i < 4);
put"mean[ "i "]="mean(i);
i=i+1;
end;
dropi;
run;
datamydata;
arraymean[3] (100,200, 300);
avg= mean(of mean1-mean3) ;
putavg=;
run;

/*
NOTE: 数组 mean 与 SAS 提供的或用户定义的函数同名。该名称之后的括号按数组引用而非函数引用处理。
ERROR: 为数组“mean”指定的数组下标过多。
*/
```

- **数组元素完全当变量使用：**由于 array 语句是 DATA 步内的编译语句，因此数组元素的引用方式不能完全等同于变量。比如在drop, keep 等语句中，元素的引用方式会被认为语法错误。变通的方法是使用该数组元素真正的变量名。比如，下面的例子企图用 drop 语句将第一个变量从输出变量列表中删除，就会引发语法错误。

  ```
  datamydata;
  arrayy [3] y1-y3 (100,200,300);
  dropy[1]; /*应该使用 drop y1; */
  run;
  ```

  

**结语**

数组操作是很多复杂分析算法的基础，利用 SAS 数组可以将传统编程语言中的算法轻松移植到 SAS 中来，从而实现自定义分析算法的编程工作。在 SAS 里实现对大规模数据的处理可以基于数组，SAS 数据集，或者利用专门面向矩阵运算的 SAS/IML 来实现，本文只覆盖基本的数组处理内容。



## 10 - 流程控制

计算机编程语言经过几十年的演化，语法元素基本上都很成熟。语法本质上就是关键字、符号以及它们如何组合的规范。各种编程语言在数据类型与结构、流程控制、实体引用与代码重用、设计哲学等方面各不相同，但它们在编程的 “语义”角度上看还是大体相同的，因此如果掌握了计算机语言的设计精髓，精通多种计算机语言并非难事。本章主要讲述 SAS 语言的流程控制有关的内容。



所有的编程语言都支持代码自上而下的**顺序处理**，这与人类的阅读习惯和文件读取处理顺序是一致的。在逻辑上，**顺序处理**、**分支控制**和**循环控制**构成编程语言在执行流程上的千变万化。同时，高级语言也会提供强大的实体引用和重用技术，比如静态代码包含 include、宏展开 macro、函数封装 function、面向对象 Object-Oriented 甚至是代码模板和泛型等等，从而为我们分解问题，解决问题、编写大规模程序成为可能。**顺序、分支和循环是构成程序流程控制的三大部分，且顺序执行是自然隐含的行为；因此重点是分支控制和循环控制。**



#### - 语句块 DO-END

在讲述流程控制之前有必要先讲 DO-END 语句块，在 SAS 语言中，我们可利用 DO-END 语句对**将包含在他们之间的多条语句封装为一个语句块，DO-END 语句块在语法上被视为一条语句处理**。在功能上类似于 C++/Java 语言中的 {} 分组符。**这种分组语句最常见的用法是在 IF-THEN 条件分支中用来实现语句块功能和代码嵌套**。实际上，**在 SAS 代码的任何地方都可以使用 DO-END 语句块来控制代码的分组和缩进**。其基本语法是：

```
DO;
statement-1*;*
…
statement-n*;*
END;
```

比如：

```
datanull;
n=4;
do;
put"Hello World";
n=n+2;
end;
ifmod(n, 2)=0then
do;
sum=sum+n;
putn=;
end;
run;
```



#### - 分支控制 IF-THEN

分支控制的作用是：如果表达式 exp 为真，执行 true-statement；否则执行 false-statement，其中表达式为假的部分是可选的。其基本语法如下：

```
IFexpTHENtrue-statement;
<ELSEfalse-statement;>
```

在 SAS 语言中，表达式求值结果可能为缺失值、零或者非零值。 ***SAS 视缺失值和零为假，其余则当作是真***。在上面的分支控制中，**ELSE**语句并非必须，也就是说可以仅在表达式为真时作某种处理。

举个例子：利用 SAS 生成满足正态分布的随机数，用**IF-THEN** 判断是正数还是负数。

```
datanull;
v=rand('NORMAL');
sign_v=0;
if v >=0 then sign_v=1;
put"v="v "sign_v="sign_v;
run;
```

**系统输出：**

v=-0.518828349 sign_v=0

**包含 ELSE 子句的例子**：利用 SAS 生成满足正态分布的随机数，如果为正数计入 post_v，如果为负数计入 neg_v 中。

```
datanull;
v=rand('NORMAL');
pos_v=0; neg_v=0;
ifv >=0thenpos_v=pos_v + 1;
elseneg_v=neg_v + 1;
put"v="v "pos_v="pos_v "neg_v="neg_v;
run;
```



**系统输出：**

v=1.3743208309pos_v=1neg_v=0

如果在**IF-THEN的处理中需要执行多条语句，我们可以使用前面讲到的 DO-END**语句块功能。DO-END 语句块中可包含任何其他 SAS 语句，包括嵌套 DO-END 块、嵌套的分支控制语句和循环控制语句。其形式为：

```IF*exp*THEN
IFEXPThen
DO;
true-statement-1;
...;
true-statement-n;
END;
ELSE
DO;
false-statement-1;
...;
false-statement-n;
END;
```

可以考察如下语句：

```
datanull;
v=rand('NORMAL');
sign_v=0; pos_v=0; neg_v=0;

ifv >=0then
do;
sign_v=1;
pos_v=pos_v + 1;
end;

else

do;
sign_v=0;
neg_v=neg_v + 1;
end;
put"v="v "sign_v="sign_v "pos_v="pos_v "neg_v="neg_v;
run;
```

**注意：**SAS DATA 步支持一个很特殊的**取子集 IF 语句**，表示数据集中观测符合特定条件才继续处理。该语句没有 IF-THEN 结构而只有 IF 表达式，千万不要与这儿探讨的**IF-THEN** 条件分支语句混为一谈。其语法为：**IF***exp*;

比如：

```
datamyclass;
setsashelp.class;
ifsex="M"; /只选取sex=”M”子集/
run;
1
```



#### - ELSE-IF 多分支控制

当我们需要多个分支控制时，可以使用**嵌套的 IF-THEN 语句**，在语法等价于在 IF 和 ELSE 之间插入任意多个**ELSE IF** 语句或语句块，从而实现多分支控制。其基本语法如下：

```
IF exp-1 THENstatement-1;
ELSE IF exp-2 THENs tatement-2;
…
ELSE IF exp-n THEN statement-n;
ELSE statement-x;
2
```



#### - SELECT-WHEN 多分支控制

SAS 提供类似于 Java 语言中的 switch-case 语法，用于多分支控制。其基本语法如下：

```
SELECT(exp-0) ;
WHEN(exp-1) statement-1;
…
WHEN(exp-n) statement-n;
<OTHERWISEstatement-x;>
END;
```

SAS 首先对 SELECT 中的表达 exp-0 求值，然后尝试匹配 WHEN 语句中列出的**一或多个表达式**（比如 exp-1），如果匹配则执行 WHEN 语句中指定的语句 (比如：statement-1)，并跳出 SELECT 。这意味着 SAS 的 Select 多分支选择语句自带 **break** 功能，而不像 C 或者 Java 的 switch-case 分支语句需要人为添加**break** 功能。比如，下面的例子生成随机的整数，如果是 0，1，2 输出对应值，否则输出 4+。

```
datanull;
v=rand('GEOMETRIC',0.25);
put"v="v;

select(v) ;
when(0) put "0";
when(1) do;
put"1
end;
when(2) do;
put"2";
end;
otherwise put "4+";
end;

run;
```

在上面的例子中，如果在 SELECT 中指定了表达式 v，则 WHEN 中也必须是一个或多个表达式，如果它们的表达式求值相等则执行 WHEN 后面的语句。**更多的情况是我们希望在 When 中指定条件表达式，这时要记得千万不要在 Select 中指定任何表达式或者变量，否则不会得到期望的行为**。考察如下代码：

```
datanull;
v=rand('NORMAL');
put"v="v;

select; /* 注意：select(v) 将不正常工作 */
when(v < -1) put "<-1";

when(-1<= v <=-0.5) do;
put"-1.0 ~ -0.5";
end;

when(-0.5<= v <= 0.5) do;
put"-0.5 ~ 0.5";
end;

when(0.5<= v <= 1.0) do;
put"0.5 ~ 1.0";
end;

otherwiseput ">1.0";
end;

run;
```



#### - 循环控制

SAS 语言有强大的循环控制支持，包括**指定次数的循环（即其他语言中的 FOR 循环）、指定条件的循环（DO-WHILE和DO-UNTIL）**和**指定集合的循环（即其他语言中的 FOREACH 循环）**三大类，在 SAS 语言中都是统一用 DO 语句实现，但形式不同！



##### 1 **指定次数的循环：DO-TO-BY**

当循环次数固定时，我们可以使用定数循环，比如在遍历数据集或者数组元素时常用。其中 BY 部分是可选的，循环的步长 step 缺省为 +1 。

```
DO var=start TO finsih BY step;
…SAS 语句…
END;
```

比如：对于一个一维数组，我们可以用循环语句将每一个元素打印出来，其中 DIM 函数用于返回数组的长度。

```
datanull;
arraymyarray [5] temporary(1,2,3,4,5);
doi=1todim(myarray);/如果要打印1，3，5,可加上 by 2/
putmyarray[i]=;
end;
run;
```

**系统输出：**

myarray[1]=1

myarray[2]=2

myarray[3]=3

myarray[4]=4

myarray[5]=5



##### 2 指定条件的循环: DO-WHILE 或 DO-UNTIL

- **DO-WHILE 循环：**当特定条件为真的时候执行循环体中的语句, 循环体执行结束后再次判断循环条件是否为真，如果真继续执行，否则结束循环。

```
DO WHILE();
…SAS语句
END;
```

比如，求1-4的累加和：

```
datanull;
sum=0;
n=0;

dowhile(n<5);
sum=sum+n;
putn= sum=;
n=n+1;
end;

run;

```

**系统输出：**

n=0 sum=0

n=1 sum=1

n=2 sum=3

n=3 sum=6

n=4 sum=10



- **DO-UNTIL 循环：**执行循环体，直到表达式为真的时候结束循环。DO-UNTIL 循环控制语句被用于**至少需要执行一次循环****体**的情况。

```
DO UNTIL();
…SAS语句…
END;
```

比如：从 0 开始执行直到 n 大于 5 时结束，并求累加和 sum 。

```
datanull;
sum=0;
n=0;

dountil(n>5);
sum=sum+n;
putn= sum=;
n=n+1;
end;

run;
```

**系统输出：**

n=0 sum=0

n=1 sum=1

n=2 sum=3

n=3 sum=6

n=4 sum=10

n=5 sum=15

**你可以看到，循环输出了 5** **次，比前面 DO-WHILE 语句多了一次**。理论上任何 DO-UNTIL 循环可以变换条件采用 DO-WHILE 循环实现。比如上面的例子，**我们可以更改循环条件为**do until (n>=5) ; 即可令两个例子等价。

##### 3 指定集合的循环：DO-OVER

在编程中需要大量处理集合类型的数据，比如数组、队列和字典等。Java/C# 都提供了类似的 foreach 的循环，其语法结构为

```
foreach(s in set) { statements }
```

SAS 语言提供一个比较少见于其他计算机语言的 DO-OVER 语法，可以用来对集合类型（比如数组进行遍历）进行处理，但 FOR-VOER 要求在定义集合类型时即指定集合索引变量。比如：

```
datanull;
arraymyarray(idx)$ x1-x4 ('The','Power','To', "Know");
lengthbuffer $32767;
buffer="";

doovermyarray;
putidxmyarray; /下标名要保持一致/
buffer = trim(buffer) || " "|| 
myarray;
end;
putbuffer;

run;
```

**系统输出：**

1 The

2 Power

3 To

4 Know

The Power To Know





#### - 特殊的流程控制语句

C++/Java 语言中，我们可以用 break 或者 continue 语句在适当条件下结束循环或继续下一次循环。通常 break 用于直接结束循环，而 continue 则指不再执行循环体中该语句后面的语句，直接跳转到下一次循环开始的条件判断处。

##### 1 跳出循环语句 leave

SAS 程序中使用**leave** 语句来离开循环，等价于 C++/Java 中的**break**语句。Leave 语句可以用于 DO 循环和 Select 分支语块中。

比如：

```
datanull;
arraymyarray (5) temporary(1,2,3,4,5);
doi=1todim(myarray);
if(i=3) thenleave;
putmyarray[i]=;
end;
run;
```

**系统输出：**当进行到第3个的时候结束循环。

myarray[1]=1

myarray[2]=2



##### 2 继续循环语句 continue

SAS 程序中使用 **continue** 语句来来忽略循环体中该语句后的所有语句，跳到循环开始处继续循环。等价于 C++/Java 中的 continue。需要特别注意的是 **continue 语句只能用于 DO 循环中**。

比如：

```
datanull;
arraymyarray (5) temporary(1,2,3,4,5);
doi=1todim(myarray);
if(i=3) thencontinue; /直接跳到 do 继续下一次循环/
putmyarray[i]=;
end;
run;
```



**系统输出：**忽略第3个变量的输出…

myarray[1]=1

myarray[2]=2

myarray[4]=4

myarray[5]=5



##### 3 返回语句 return

一般情况下, **return** 语句从**当前点上立即停止执行，返回到本 DATA 步的开始处继续执行**。此时数据步会将当前观测自动从 PDV 输出到目标数据集，当数据步的最后一个语句执行后会默认 RETURN 到数据步的开始处将继续下一次隐形循环。比如下面的例子将过滤掉输入数据中两个变量差值的绝对值大于 10 的数据：

```
datanull;
inputx x1 ;
ifabs(x1-x)>10thenreturn;
putx1= x=;
datalines;
10 20
20 35
30 40
40 25
50 60
;
```

**系统输出：**

x1=20 x=10

x1=40 x=30

x1=60 x=50

**注意：RETURN语句还有一个特殊功能用于函数封装，将在后面代码复用技术的章节中介绍。**



##### 4 中止执行语句 stop/abort

在 DATA 步中，STOP 语句可以用来停止当前步的执行，并马上处理下一个 DATA/PROC 步（即执行逻辑跳出当前步）。此时，哪怕在 PDV 中已经处理完毕的观测也不会被输出到目标数据集中。STOP 语句也可以出现在 IF-THEN 或者 SELECT-WHEN 分支语句中。

如果 SAS 运行在 Windows 平台上，ABORT 语句也可以用来停止当前步的处理，区别是 ABORT 语句会设置DATA步的系统变量 _ERROR_ 为 1，而 STOP 语句不会。也就是说，ABORT 相当于可以人为结束程序并在系统日志写入错误信息：

ERROR: ABORT 语句终止了执行，位置: 行 5 列 23。

另外，当 SAS 在批处理/非交互模式下运行时，ABORT 和 STOP 也有不同的行为，如果要继续处理后续的 DATA/PROC 步，需要使用 STOP 语句。STOP 语句可以在依赖于某个外部数据的随机访问时避免死循环发生。比如下面的程序用于从系统数据集 sashelp.class 中抽样数据到 myclass 中，规则是每 5 行抽取 1 行。

```
datamyclass;
doi=1tocount by5;
setsashelp.class point=i nobs=count;
output;
end;
stop;
run;
proc print; 
run;
```



执行上面的代码将对 sashlep.class 抽样产生一个小样本，但如果没有恰当的 stop，可能导致程序不返回的情况。

![img](http://img.mp.itc.cn/upload/20170322/8f553e95bb3b424db87bbb1f89004f2e_th.png)

##### 5 跳转语句 goto/link

虽然很多现代编程语言已经抛弃了万恶的 GOTO 语句，但我们不能否认 GOTO 语句是个万能的恶魔！GOTO 语句可以让 SAS 程序**执行立即跳转到本 DATA 步内的指定标签处**，如果标签处是一个 RETURN 语句，则执行将返回到 DATA 步的开始处！GOTO 也并非毫无原则，**SAS 只允许在同一 DATA 步代码空间跳转**——随时都别忘了 **SAS 代码是以步为编译单元**啊。其基本语法：

```
GO TOlabel;
```

SAS 的 GOTO 语句中间是带空格的，但笔者推荐使用它的别名 GOTO，因为这种没有空格的 GOTO 形式与别的计算机语言是一样的。

```
GOTOlabel;
```

考察如下代码：当 i=3 的时候，程序自动跳转到标签 mylabel 处，从而结束了当前 DATA 步的执行。你可以在任何语句开头处定义标签。

```
datanull;
arraymyarray [5] temporary(1,2,3,4,5);
doi=1todim(myarray);
if(i=3) thenGOTO*mylabel*;
putmyarray[i]=;
end;
mylabel:
put"Go to here";
run;
```

**系统输出：**

myarray[1]=1

myarray[2]=2

Go to here

有时候 GO TO 语句与 RETURN 语句会配合使用，可以实现任意灵活的流程控制。比如下面的代码只将输入数据集中偶数观测进行求累加和。

```
datanull;
inputx @@;
ifmod(x,2)=0thenGOTO*addnum*;
putx=;
return;
addnum:
putx= "+";
sumx+x;
if_N_=4thenputsumx=;
datalines;
1 2 3 4
;
```

**系统输出：**

x=1

x=2 +

x=3

x=4 +

sumx=6

SAS 语言中还有一个比 GOTO 语句弱一点的跳转语句 LINK，它们功能类似但后续的 return 语句行为不同，通常用于实现扁平模式下函数封装，后续章节将会讲到。



结语

SAS 语言不但提供所有现代编程语言都有的流程控制机制，同时也保留了很多从语言定义之初就有的语言元素。灵活应用这些流程控制机制，程序员可写出各种各样灵活的数据处理程序：**数据分析行业几十年的实践证明，完成同样的数据处理功能的 SAS 程序远比完成同样功能的 Java/C++ 程序简洁而高效**。况且连万能的 GOTO 语句至今都还保留着，还有什么程序控制是你想写却不能实现的？当然，程序除了流程，我们还需要代码封装和复用，这些将在下一章讲述。



## 11- 函数封装 (1)

计算机编程语言用于告诉计算机做什么，如何做。编程思想的发展史就是人类不断总结如何控制机器，实现丰富多彩程序世界的历史。在计算机发展的早期阶段，编程技术既没有我们现在熟知的结构化思想，也没有函数封装概念，更不用谈什么面向对象和泛型；所有可用的编程元素就是现在汇编语言中大家能看到的那些指令集，编程几乎就是在告诉计算机CPU如何加载数据和指令，如何与寄存器打交道，执行跳转与执行等等。

#### - GOTO语句

后来结构化编程思想日趋成熟，面向过程的编程技术开始兴起，过程和函数封装的概念才开始流行。如今函数仍然是我们封装计算逻辑的基本单元。**函数定义由函数名称，参数列表，基于参数和变量作用域的计算逻辑、以及函数的返回值构成**，在计算机内存中，一个操作系统可以调度的进程在内存分配上包含代码段和数据段，以及数据段之上的代码堆（函数编译形成），顶部则是堆栈；堆栈中每一个栈帧代表了一次函数调用，其中包括上一栈帧的地址，输入参数、返回值…以及返回地址等。虽然很多程序员已经不再探求函数编译和调用的细节，但作为SAS数据科学家还是需要深刻理解这一点，才能掌握SAS编程的精髓。首先我们回顾一下在计算机发展的早期阶段，计算机科学家是如何实现函数封装这一概念的？然而，我们还不得不从程序执行跳转语句GOTO的命运开始说起。

GOTO语句的作用非常简单，就是将程序执行跳转到指定语句。然而，结构化程序设计之父Edsger Wybe Dijkstra在1968年的论文《Go To Statement Considered Harmful》中指出：**GOTO语句会使分析和验证程序正确性（尤其是循环控制）的任务变得复杂，认为不加限制地使用GOTO语句应当从高级语言中废止。**而另一方面，经典巨著《计算机程序设计艺术》的作者Knuth Donald Ervin在1974年的论文《Structured Programming with go to Statement》则**分析了许多常见编程任务，认为其中一些使用GOTO能得到最理想的程序结构，有控制地使用一些GOTO语句是必要的!** 这就是计算机编程历史上著名的GOTO语句之争。

哪怕是我们这个时代最伟大的两位计算机科学家，尚且对GOTO语句的存亡看法不同，似乎我们就不必进一步探索其存亡的合理性，而更应该关注如何合理使用它。现实情况是：C/C++ 语言到目前为止仍然保留了GOTO语句，而Java语言虽然不支持GOTO语句却保留了GOTO关键字，C# 语言则依然坚定支持GOTO语句——尽管我们已经迈入了面向对象和泛型的高级编程时代——但GOTO语句在跳出多重循环，处理发生错误时的清理资源非常高效。（据说Linux-2.6.21内核代码中就使用了超过20,333个GOTO语句）。在某种意义上，GOTO语句是计算机汇编语言时代JMP指令在高级语言中的残留，而高级计算机语言分支循环控制中的BREAK和CONTINUE语句在本质上也是一种受限的GOTO语句。

SAS语言仍然明智地保留了强大的GOTO语句。下面的例子演示了使用GOTO语句的一个使用场景——跳出多层嵌套循环。

```
datanull;
dox=1to10;
	doy=1to10;
		doz=1to10;
		if(xyz=125) thengotoexit;
		end;
	end;
end;
return;
exit:
putx= y= z= 'EXIT LOOP AT xyz=125';

```

如果不用 GOTO 语句，等价的实现代码为：

```
datanull;
found=0;
dox=1to10;
	doy=1to10;
		doz=1to10;
		if(xyz=125)thenfound=1;
		iffound=1thenleave;
		end;
	iffound=1thenleave;
	end;
iffound=1thenleave;
end;
iffound=1thendo;
putx= y= z= 'EXIT LOOP AT xyz=125';
end;
run;
```

在SAS语言中要实现汇编时代的函数封装风格，我们可利用GOTO语句的一个变体LINK语句来实现。理解它将对我们在SAS语言的世界里实现任何复杂的执行逻辑都不再畏惧。



#### LINK-RETURN技术

LINK语句是一种特殊的GOTO语句，**它可以将程序执行马上跳转到同一DATA步内所指定的标签处；如果后续执行中遇到RETURN语句，执行会跳转回该LINK语句后的下一条语句继续执行**。**LINK**语句默认最多可嵌套10层，但SAS编程人员可以通过DATA语句的/STACK选项来增加嵌套的LINK语句层数。下面的图示展示了LINK和GOTO语句的区别：左边的编译结果是4个语句，而右边只有2个语句，最末的RETURN返回DATA步开始处。

![img](http://img.mp.itc.cn/upload/20170420/a6a5f65c0eff433c9df1a17924aaf56a_th.jpeg)

LINK与GOTO语句的区别是其后RETURN语句的行为不同——LINK语句跳转执行后遇到RETURN语句时会返回该LINK语句的下一条语句（注：如果需要执行一组语句，你可以使用DO…END分组语句来封装）继续执行；而GOTO语句跳转后遇到的RETURN语句则返回到DATA步的开始处（除非GOTO后面又有LINK语句，该LINK后的RETURN语句返回该LINK语句的下一条语句）。**LINK语句通常跟着显式的RETURN，而使用GOTO语句时通常不需要一个RETURN语句。**当然，程序员有义务控制执行逻辑防止死循环。



##### 语法：LINK label

下面我们举一个完整的例子来说明如何使用LINK-RETURN来实现函数封装功能，该函数执行将两个数相加，放到第三个数中。

```
datatest;
x=1; y=2;
link func_add; /调用函数 func_add/
output; /*将运算过程 x y z 都输出到数据集 test 中 */

putx= y= z=;/打印结果到日志中/
x=3; y=4;
linkfunc_sub; /调用函数 func_sub/
output;
putx= y= z=;
return; /返回 DATA 步的开始处，防止func_add 被自动执行/
func_add:
z=x+y; /执行加法运算 z=x+y/
return; /返回跳入此处的那个 LINK 语句的下一条语句/
func_sub:
z=x-y; /执行减法运算 z=x-y/
return;
run;

proc printdata=test; run;
```

输出结果如下：

x=1 y=2 z=3

x=3 y=4 z=-1

![img](http://img.mp.itc.cn/upload/20170420/65eb45d5504d469bb4270bbe54c778b4.png)

如果对一系列数据输入执行加法运算，我们也可以用同样的原理进行伪函数封装。演示代码如下所示：

```
datatest;

inputx y;

LINKfunc_add;

output;

putx= y= z=;

return; /返回 DATA 步的开始处/

func_add:

z=x+y;

return; /返回跳入此处的那个LINK 语句的下一条语句/

cards;

1 2

3 4

;

run;

proc**printdata=test;run**;

```



**系统输出如下：**

x=1 y=2 z=3

x=3 y=4 z=7

![img](http://img.mp.itc.cn/upload/20170420/10f15ac3dd25402682c5551e1f8c73d0.png)

如果要实现函数的递归调用，我们该如何用这种LINK-RETURN实现呢？要实现递归，形式参数和实际参数必须分离，并且要在没有作用域的DATA步中自己实现函数封装和调用细节。有兴趣的读者可以参阅作者的河内塔问题求解探索一文，其中包含了基于这种思想实现的函数封装技术。

**SAS宏函数封装**

SAS语言中SAS宏也可以用来封装函数。实际上很多时候SAS程序员已经在滥用这种函数封装技巧。考察如下SAS代码，看我们如何演变为SAS宏封装。首先我们可以直接在DATA步中编写计算逻辑 z=x+y，功能跟前面的代码一模一样。

```
datamydata;
inputx y;
z=x + y; /待封装的计算逻辑/
cards;
1 2
3 4
;
run;
proc**printdata=mydata;run**;
```

利用SAS宏将计算逻辑z=x+y进行剥离并封装，这样我们就可以在多个数据集中重用这一SAS宏函数。

```
%macrofunc_add( arg1, arg2, arg3);
&arg3= &arg1 + &arg2;
%mend;

datamydata;
inputx y;
%func_add(x,y,z);
cards;
1 2
3 4
;
run;
proc**print;run**;
datamydata2;
inputa b;
%func_add(a,b,c);
cards;
5 6
7 8
;
run;
proc**print;run**;
```



![img](http://img.mp.itc.cn/upload/20170420/740c9f5d594245199afecb9ffa5b7aa3_th.jpeg)



除了上面在变量级别进行宏函数封装，我们也可以在数据集的层面上进行SAS宏函数封装。这样我们甚至不必在SAS数据步内进行调用，而是在数据步外面进行控制：

```
%macrofunc_add( arg1, arg2, arg3,ds, ds2);
%if&ds = %then%do;
%letds=&SYSLAST;
%end;
%if&ds2 = %then%do;
%letds2=&ds;
%end;
data &ds2;
set &ds;
&arg3= &arg1 + &arg2;
run;
%mend;
datamydata;
inputx y;
cards;
1 2
3 4
;
run;
%func_add(x,y,z); /未指定输出数据集时，直接将结果写入源数据集/
proc**print; run**;
datamydata2;
inputa b;
cards;
5 6
7 8
;
run;
%func_add(a,b,c,mydata2,mydata3); /指定输入数据集和输出数据集/
proc**print; run**;
```

SAS宏非常强大，后面的章节中将会专门讲述。程序员掌握这些封装技巧对于写出规范的SAS代码极其重要。要记住的一点是，任何形式的SAS宏函数封装，其展开后的SAS代码仍然必须符合SAS语言规范。现实中SAS程序员很容易犯的一个错误是，在数据步内调用另一个宏函数，而该宏函数已经包含一个完整的数据步，SAS编译器会因为两个数据步嵌套而报错。

**FCMP函数**

从SAS 9.1开始，SAS提供过程步PROC FCMP来进行函数封装。它可以创建，测试和存储用户自定义函数，CALL例程以及用户自定义函数库。PROC FCMP封装的函数可在数据步内自由调用，具有非常好的通用性。当然，在某些过程步比如PROC IML中也提供函数封装功能，但其作用范围是有限的。本节主要演示PROC FCMP的函数封装功能。

首先，我们可以使用PROC FCMP过程步来进行函数定义，它输出一个包含指令系列的 SAS函数库（表现为SAS数据集形式）；每个SAS函数库可以包含多个函数包，函数包则可以包含若干函数。故FCMP的outlib参数是一个3级名称，libname.dataset.package。函数编译结果默认是明文形式，但用户可使用该过程步的HIDE选项来隐藏存于VALUE列中的明文代码，以保护SAS源 代码。比如：

```
datanull;
n=4;
do;
put"Hello World";
n=n+2;
end;
ifmod(n, 2)=0then
do;
sum=sum+n;
putn=;
end;
run;
对于生成的FCMP数据集，我们也可使用PROC FCMP来查看函数定义的原型：
proc**fcmp**inlib=work.funcs listfuncs;
run;
```

系统输出：

![img](http://img.mp.itc.cn/upload/20170420/3e24b202cb524836b07cf03fee059698_th.png)

一旦编译生成SAS数据集后，我们就可以在任何需要该计算逻辑的地方引用这个函数。SAS系统选项cmplib用于指定当前SAS程序需要引用的一个或多个函数库（即PROC FCMP生成的SAS数据集）。比如：

```
optionscmplib=work.funcs;
datamydata;
inputx y;
z=add(x,y); /使用我们自己定义的加法函数/
cards;
1 2
3 4
;
run;
proc**printdata=mydata;run**;
datamydata2;
inputa b;
c=multiply(a,b);/使用我们自己定义的乘法函数/
cards;
5 6
7 8
;
proc**printdata=mydata2;run**;
```

FCMP函数默认只能有一个返回值，当我们需要有多个返回值时，可以使用outargs来指定需要返回的参数，从而实现单个函数返回多个返回值。当然，也可以使用outargs修饰的数组参数来返回批量计算结果。比如下面的例子按照黄金分割比例分割一个数。

```
/*按照黄金分割比例分割arg1, 作者：yinliangwu@gmai.com */
proc**fcmp**outlib=work.funcs.math;
function decomposite( arg1, ret1, ret2);
outargs ret1;
outargs ret2;
theta=(1+ sqrt(5))/2;
ret1= arg1 / (1+ theta) * theta ;
ret2= arg1 / (1+ theta);
return (1);
endsub;
run;
optioncmplib=work.funcs;

datanull;
v1=10;
v2=0; v3=0;
rc=decomposite(v1, v2, v3);
putv1= v2= v3=;
run;

当需要引用多个函数库时，我们可在cmplib中用空格或逗号分隔来指定多个参数。比如：
/逐一指定/
optionscmplib=(work.math1 work.math2 work.math3);
/也可批量指定math1,math2,math3/
optionscmplib=(work.math1 - work.math3);
```

当分析人员在分工合作编写大型分析项目时，我们可能在定义函数原型的时候就需要引用别人写的代码。因此我们需要在PROC FCMP中使用library参数来链接别人写好的SAS函数库。当我们引用了多个函数库，也可以像cmplib系统选项一样的形式来引用若干函数库。比如，创建**平方和函数**需要使用work.funcs函数库定义的加法和乘法函数：

```
proc**fcmp**outlib=work.funcs2.math2 library=work.funcs;
function square(arg1, arg2); /封装平方和 x^2 + y^2 计算逻辑/
ret=add(multiply(arg1, arg1), multiply(arg2, arg2)) ;
return(ret);
endsub;
run;
/函数调用时也要将原来链接的函数库链入/
optioncmplib=(work.funcs2 work.funcs);
datamydata;
inputx y;
z=square(x,y);
cards;
1 2
3 4
;
run;
proc**printdata=mydata;run**;
```

**系统输出如下：**

![img](http://img.mp.itc.cn/upload/20170420/1a73712e6ff0498884b604ab50f16367.png)

**注意：**如果只想定义没有返回值的函数（在SAS里称为子例程）该怎么办？只需要在定义中将**function**改为**subroutine**（这一点与VB和VB语言的SUB类似），且**不要使用return**语句进行返回即可。而在调用函数时需要在前面加上call。

PROC FCMP中不但可

]以调用**别的FCMP输出的函数模块**，我们也可以在其中**调用宏函数**。比如，下面的例子就是FCMP重用SAS宏定义的加法函数。

```
%macro**Add**;
data null;
ret= &arg1 + &arg2;
call symput('add_ret', ret);
run;
%mend;

proc**fcmp**outlib=work.funcs.math;
function add(arg1, arg2);
rc = run_macro('Add', arg1, arg2, add_ret);
if rc = 0then return(add_ret);
elsereturn(.);
endsub;
run;
optioncmplib=(work.funcs);
datamydata;
inputx y;
z=add(x,y);
cards;
1 2
3 4
;
run;
proc**printdata=mydata;run**;
```

上面的代码展示了在PROC FCMP中重用SAS宏函数的能力，它为我们在一个数据步内调用另一个数据步内计算逻辑提供了可能。

其实，SAS语言中还可以调用其他计算机语言编写的函数库，比如C语言、Java语言函数库，甚至Win32系统动态库。有一些人对SAS语言充满偏见是因为SAS语言实在太灵活，以至于让很多编程人员找不到一个类似于其他计算机语言中常见的框架或者代码范式。这需要编程人员站在一定高度去认识SAS语言的特性；关于如何在SAS里实现复杂的数据结构和指针操作等等，将在函数封装（下）的章节中作进一步阐述。

小任务

请用所学的函数封装技巧分别实现阶乘功能；比如5!就是5 x 4 x 3 x 2 x 1，即 facterial(5)= 120



## 12- 宏（上）

技术大咖——巫银良先生继续分享“如何从程序员成为一名数据科学家”系列文章，今天将与大家分享“ SAS 宏”，赶紧学习起来吧~~

在传统编程语言 C/C++ 中，我们可以使用预处理语句 #define 来定义宏变量，也可以使用其他以 # 号开头的宏语句来实现条件编译功能，比如 #ifdef ….#else… #endif 等。很多语言（如 Java ）则不提供预处理宏支持，编程人员只好使用静态常量以及泛型技术来实现类似的控制机制。C# 语言为了灵活的编译控制依然保留了 #define、#if、#else、#endif 等宏语句。那么宏到底是什么神秘的东西？SAS 语言中的宏又是如何工作的呢？

总体来说，宏技术在编译领域的作用就是告诉编译器在正式代码编译之前，由预处理器根据一系列预定义的规则有条件地对源代码进行文本替换，称之为宏展开。宏技术是编程语言之上的更大范围更高级的一种抽象（据《康熙字典》：宏賁皆大也），它能在源码更高的层次上提供灵活的逻辑控制能力。

SAS 宏比传统编程语言的宏支持有过之而无不及，它实现了 SAS 代码的一种复用，让 SAS 编程更加精巧和灵活。SAS 宏易于学习，但也很容易令人困惑，因为程序员很容易将宏本身，跟宏展开后的输出混为一谈。SAS 宏系统非常强大，不但包括一般编程语言支持的宏变量替换和条件分支控制，而且还支持更加高级的循环控制、以及宏函数（系统宏和用户自宏）。SAS 宏本身已经发展成一种计算机语言，在更高的层面上对 SAS 源代码进行操纵实现分析数据、编写报告以及自动执行代码等功能。

通过前面的学习我们知道 SAS 程序由各种 SAS 语言编写的语句（比如 DATA/PROC 步、全局语句等）组成，但 SAS 代码中其实还可以包含 SAS 宏语言、 SCL 语言和 SQL 语言编写的语句。**SAS 代码提交执行时，源代码首先被读入计算机内存的输入缓冲区进行字符扫描，如果代码包含 SAS 宏特定的字符 & 和 % （ 前者标识宏变量，后者标识宏语句 ），这些代码就会触发宏处理器进行宏展开，展开后的代码会再次输出到输入缓冲区继续扫描处理。** 宏展开完毕的 SAS 代码才会交由 SAS 编译器进行词法分析和编译运行。需要特别注意一点是，SAS 宏技术的引入并未减少 SAS 程序的执行时间，而是减少编写重复或类似的 SAS 代码，从而增强了 SAS 程序的可读性。

SAS 代码预处理机制如下：

![img](http://img.mp.itc.cn/upload/20170429/dfafbb794e8e4be695e0096723934c4e.png)

##### -  宏变量

宏变量本质上就是一种**字符类型的变量**，由它的**名字和值共同构成一个符号表**。宏变量的值可以来自真正的 SAS 变量，数字或文本甚至是宏表达式。 SAS 源代码中出现 % 号和 & 号的地方（包括双引号括起来的字符串中）都是 SAS 宏出没的地方。

- 命名：SAS 宏变量命名遵循 SAS 命名规则，可以是字母、数字或下划线，但必须以字母或下划线开头，最大长度不得超过 32 字节长度。如果定义宏变量的时候该宏变量在系统符号表中已经存在，系统会自动覆盖已有的宏变量。

  宏变量可以使用 %GLOBAL 或 %LOCAL 语句预先定义，也可以直接用 %LET 语句定义并赋值（%LET 语句主要用于赋值，仅在宏变量没有定义时才自动创建）。随后的代码中可使用 & 宏变量名 对宏变量进行引用。其基本语法如下：

```
%LETmacro-variable =<value>;
```

比如：

```
%LETFOO=VALUE;
%PUT&FOO;
```

系统输出：VALUE

- 当使用 %LET 语句对宏变量进行赋值时，其等号右侧的“内容” 遵循如下规则：

  1、首尾的连续空格在赋值前会被自动删除

  2、数值也是被作为文本看待，数学表达式也不会被求值，除包含在特定宏函数中进行求值。

  3、引号本身也是作为宏值的一部分而存在，而不是字符串标记符号。

  4、文本长度必须介于 1 - 65534 字符之间；注意：比程序员最熟悉的 16 位无符号整数的最大值 65535 少 1 ！

- 作用域：宏变量有作用域的概念，宏变量可以在 SAS 会话中全局有效，或者在 SAS 宏函数中局部有效。如果宏变量是定义在一个 SAS 宏函数（因为通常用来封装成函数，常称为宏函数）内部，它的作用域就是局部的，只能在该宏函数内起作用。但如果我们定义在任何宏函数外，则我们可在 SAS 程序任何地方都可使用这种已经定义的全局宏变量。考察如下代码：

```
%PUT&FOO; /试图引用一个不存在的宏变量/
```

输出：
WARNING: Apparent symbolic reference FOO not resolved.
&FOO

如果改为：

```
%LETFOO=GLOBAL;
%PUT&FOO;/输出：GLOBAL/
```

输出：GLOBAL

如果 %LET 语句在一个 SAS 宏函数内部给某个宏变量赋值，默认情况下该宏变量是局部变量。如果 %LET 语句在开型代码中，则该宏变量为全局变量。

在调用宏变量赋值语句 %LET 之前，我们可使用 %GLOBAL 和 %LOCAL 语句对宏变量进行预先定义，分别指定宏变量的作用域是全局还是局部。如果已经定义了某个全局宏变量，同时在某个宏函数内部再次用 %LOCAL 定义一个同名宏变量，则宏处理器在执行该宏时使用局部定义的宏变量值，而在该宏外部使用全局宏变量的值。比如下面的代码将输出： GLOBAL GLOBAL LOCAL **GLOBAL** ，最后一个输出的是 GLOBAL 而不是宏 MyMacroFunction 内指定的值 LOCAL 。归根结底，**局部宏是定义于宏函数自带的符号表中，而非全局符号表中；宏变量的查找顺序是先从宏函数局部符号表先查找，然后再从全局符号表中查找。**

```
%LETFOO=GLOBAL;
%PUT&FOO; /输出：GLOBAL/
%MacroMyMacroFunction;
%PUT&FOO; /输出：GLOBAL/
%LOCALFOO;
%LETFOO=LOCAL;
%PUT&FOO; /输出：LOCAL/
%MEND;
%MyMacroFunction;
%PUT&FOO; /输出：GLOBAL/
```

系统宏：系统宏是预先定义在全局符号中的一系列宏变量，它们在当前 SAS 会话中全局有效。比如全局宏变量 &SYSDATE 和 &SYSTIME，分别表示当前 SAS 会话开始的日期和时间。检测当前 SAS 会话中到底有哪些宏被定义了，可调用 %PUT 语句来显示。比如：

```
%PUT_ALL_; /列出所有宏变量/
%PUT_AUTOMATIC_;/列出所有系统定义的宏变量/
%PUT_GLOBAL_; /列出所有全局（会话级）宏变量/
%PUT_LOCAL_; /列出所有局部（正在执行的宏）宏变量/
%PUT_USER_; /列出所有用户定义的宏变量/
```

对已经定义的宏变量使用 & 宏变量名 来进行引用，但 SAS 系统对包含在单引号内的文本不会进行宏展开。程序员可在代码中直接引用宏变量，也可在双引号文本中引用宏变量。比如：

```
%LETdsname=sashelp.class;
%LETauthor=Yinliang Wu;
title"Content of dataset &dsname"; /双引号中引用宏变量/
title2'Author: &author'; /单引号中不作宏展开/
procprintdata=&dsname; /直接引用宏变量/
run;
```

上面的代码会输出期望的报表标题，但 title 2 语句中的宏变量 &author 并不工作，原因是我们在 title 2 语句中使用了单引号来包含字符串，而单引号字符串不会被宏展开；如果换成双引号即可正常工作。

![img](http://img.mp.itc.cn/upload/20170429/afd4d26e0b754b0286d0afc778301449.png)

```
x%LETvar1=Leon;
data_null_;
put"&var1a and &var1ardo";
run;
```

运行代码后系统报告**没有解析符号引用 VAR1A** 和 **VAR1ARDO**，而实际上我们是希望输出 **Leona and Leonardo**，可以将**put** 语句修改如下即可：

```
put"&var1.a and &var1.ardo";
```

由于 **&** 符号作为宏变量的标识，如果需要生成 **&**符本身用于二次宏展开，可以使用 **&&** 代替。由于这一特性，我们可以定义多重宏变量引用，实现多层宏变量的逐步展开。比如：

```
%LETvar1=Leon;
%PUT&var1;
%LETvar2=&&var1;
%PUT&var2;
以上两个 %PUT语句都是输出 Leo
```

**宏代码调试**

SAS 主要提供两个系统选项 mprint 和 mlogic 来帮助我们调试宏代码，用于静态检查宏展开生成的代码以及动态跟踪宏的执行过程。

- 静态检查宏展开代码

```
optionsmprint; /是否打印生成的 SAS 语句代码？ 缺省为 NOMPRINT/
options mprintnest; /mprint 时是否显示嵌套? 缺省为 NOMPRINTNEST/
options mfile; /打印时是否输出到外部文件, 缺省为 NOMFILE/
/若已启用mfile 系统选项且指定了mprint 文件引用，代码会输出到外部文件/
filenamemprint 'c:mymacro.sas';
%macroprintclass();
proc print data=sashelp.class;run;
%mend;
%printclass;
```

- 动态跟踪宏执行过程

```
optionsmlogic; /是否跟踪宏处理器执行过程？缺省为 NOMLOGIC/
options mlogicnest; /mlogic 时是否显示嵌套？缺省为NOMLOGICNEST/
```



**宏表达式**

与 SAS 表达式类似，SAS 宏也支持表达式，称为宏表达式。它可用于求值运算或逻辑控制。SAS 宏表达式可包含算术运算符、逻辑运算符和比较操作符。SAS宏表达式在语义上跟 SAS 表达式基本一致，很多普通SAS语句加上%号即可从普通 SAS 代码变为 SAS 宏代码。但需要注意：

- 宏代码中的逻辑运算符 AND、OR、LT、GT… 不必且不能使用百分号。

- 宏表达式不支持 BETWEEN … AND 这种特殊的 SAS 比较运算形式。

  比如 SAS 代码 50.0 <= &Weight <= 80.0 语义等价的宏代码必须使用多个比较表达式，然后用 OR 或 AND 连起来。

- 宏表达式中可以有括号 () 来进行分组，但有时省略括号 () 也可正常工作。

```
%MacroTEST;
%LETA=8;
%IF0< &A AND &A < 5%THEN%PUTInside;
%ELSE%PUTOutside;
%MEnd;
```



- 由于宏的本质是文本替换，宏里面的字符内容不需要使用单引号或双引号括起来，而且宏表达式作为字符串值是大小写敏感的。

```
%LETa=Hello World;
%LETb=HELLO WORLD;
%LETc="Hello World";
%PUT&a &b &c; /* 输出：Hello World HELLO WORLD "Hello World"*/
```

由于宏展开本质上是文本替换，宏变量只能包含文本（哪怕是数值也是以文本存在的）内容，但 SAS 宏支持对宏表达式进行算术运算、逻辑运算和比较运算。SAS 提供 %EVAL 和 %SYSEVALF 两个系统宏函数，可对宏表达式进行求值。两者的区别是前者只支持没有小数点的整数表达式，而后者可支持浮点运算（表达式中或求值结果中可包含小数点），甚至可以指定转换的数据类型。然而，如果表达式中不包括运算符时，宏函数会直接返回表达式原值。两个系统宏函数的语法如下：

%EVAL (*expression*)

%SYSEVALF*(expression, conversion-type )*

请考察如下代码：

```
%LETexp=4/3;
%LETeval_V1=%eval(&exp);
%PUT&eval_V1; /输出：1/
%LETexp1=3; %LETexp2=4;
%PUT%sysevalf( &exp1 * &exp1 + &exp2 * &exp2 );
/输出平方和：25/
%LETeval_V2=%sysevalf(&exp);
/输出：1.33333333333333而非1/
%LETsysevalf_V1= %sysevalf(2>1,boolean); /* 输出：1 */
%LETsysevalf_v4= %sysevalf(5.49,ceil); /* 输出向上取整：6 */
%LETsysevalf_v5= %sysevalf(5.49,integer); /* 输出四舍五入：5 */
%LETsysevalf_v6= %sysevalf(5.49,floor); /* 输出向下取整：5 */
%LETsysevalf_v4x= %sysevalf(-5.49,ceil); /* 输出向上取整：-5 */
%LETsysevalf_v5x= %sysevalf(-5.49,integer);/* 输出四舍五入：-5 */
```

注意：在编写宏代码时可能会遇到错误： ERROR : 检测到开型代码语句的递归 ，这往往是因为宏语句忘了用分号进行结束，从而导致宏展开无法继续。

**SAS 宏函数**

宏变量比较简单也容易理解，但 SAS 宏函数就相对复杂。比如我们需要对一系列的数据集执行一系列相同或类似的 SAS 分析代码时，我们可以考虑利用宏函数来封装“重复或类似的 SAS 代码”。 SAS 程序员不必使用拷贝/粘贴弄得源代码非常冗长，而是像封装函数一样对 SAS 代码进行高层次的代码封装，在代码编译运行前进行宏展开。

SAS 宏函数定义的基本语法如下：

```
%Macromacro-name<(parameter-list)> </option-1 <… option-n>> ;
MACRO STATEMENTS;
%MEnd;
```

在宏定义语句 %Macro 和 %MEnd 语句之间，我们可以包括任何 SAS 语句（如 DATA/PROC ），也可以包含宏变量引用，宏语句或表达式、或者对其他宏的调用，甚至是纯文本，代码注释等。需要记住的一点是，宏展开后的代码必须符合 SAS 的语法规范。

最常见的一个错误是，在一个 **DATA** 步内调用一个宏，而该宏已经封装了一个或多个 DATA 步的调用，这时系统就会编译不过。原因很简单，宏展开后会导致 DATA 步代码嵌套，从而导致语法错误。另外，用 SAS 宏封装的代码中不建议使用行注释（以 * 开始，分号结束），而应该使用块注释（以 /* 开始， */ 结束）来避免不期望的宏展开。

对于一个已经定义好的**宏函数**，可使用 **%macro-name**来进行引用；如果宏函数引用名后面是空格时，宏语句的结束符分号是可选的。

```
%macro-name[;]
```

比如，我们可以将打印数据集的 SAS 代码封装成宏，供重复调用：

```
%MacroPRINTDS;
title "Content of dataset &dsname";
proc print data=&dsname;
run;
%MEnd;
/调用1：打印sashlep.class/
%LETdsname=sashelp.class;
%PRINTDS;
/调用2: 打印sashlep.prdsale/
%LETdsname=sashelp.prdsale;
%PRINTDS;
```

运行上面的代码可以看到 SAS 宏被执行两次，分别输出 sashelp.class 和 sashelp.prdsale 两个数据集的内容。但由于上面的代码依赖于全局宏变量 &dsname，代码的耦合性不好。这时我们就需要使用宏函数的参数列表来进行封装。

SAS 宏函数的参数可以用两种方式进行定义，一种叫顺序参数（或位置参数），另一种叫命名参数（或键值参数）。

- 顺序参数：就是定义宏的时候，按照先后顺序定义所需的形式参数；在宏调用的时候，也需要按照同样的顺序提供实际参数。比如：

```
%MacroFoo(arg1, arg2,… , argn);
MACRO STATEMENTS;
%MEnd;
%Foo(V1, V2,…, Vn);
```

据此，我们修改前面打印数据集的SAS宏如下，并可以同时指定报表标题：

```
%MacroPRINTDS(dsname, title);
title "Content of dataset &title";
proc print data=&dsname;
run;
%MEnd;
/调用形式如下/
%PRINTDS(sashelp.class, Student);
%PRINTDS(sashelp.prdsale, Product Sales);
```

命名参数：在宏定义时可给参数命名，然后在实际调用的时候也采用 参数名=参数值 的方法来指定实际参数。鉴于每个参数已经定义了名称入口，函数调用时的参数位置就不再需要，并且如果在调用时没有指定参数，SAS 也会使用宏函数定义时所指定缺省值进行调用。语法如下：

```
% MacroFoo(arg1= def_V1, arg2=def_V2,…, argn= def_Vn);
MACRO STATEMENTS;
%MEnd;
%Foo(arg2=V2, argn=Vn);
```

我们再次修改前面打印数据集的样例代码，给宏函数 PRINTDS 指定参数名称和默认值：

```
%MacroPRINTDS(dsname=sashelp.class, title=Class);
title "Content of dataset &title";
proc print data=&dsname;
run;
%MEnd;
%PRINTDS(); /*以宏函数定义的默认值进行调用*/
%PRINTDS(title=My Class); /*指定title参数*/
%PRINTDS(dsname=sashelp.prdsale, title=My Product Sales);
```



**宏代码的逻辑控制**

与传统的 C 或 C++ 宏编译不同，SAS 不但提供条件分支控制，还提供循环控制。这样 SAS 宏技术就演变为 SAS 代码之上的超级代码。因此，合理巧妙地利用 SAS 宏可以写出简洁优美的 SAS 程序，而滥用 SAS 宏则会导致代码可读性差且调试困难。

- 宏语句块

与 SAS 代码一样，我们可以使用 DO-END 将多行 SAS 宏语句进行分组，DO 和 END 宏语句需要加上百分号，但功能类似。

```
%DO; … %END;
```

- 条件分支

基于一个或多个条件，选择性地执行条件块里面的代码；与非宏的 SAS 代码一样，%ELSE 语句是可选的。

```
%IF<MACRO EXPRESSION> %THEN<TRUE TEXT>;
%ELSE<FALSE TEXT>;
%IF/%ELSE语句也可以使用上面的宏语句块%DO-%END 来嵌套其他的宏语句
%IF<MACRO EXPRESSION> %THEN%DO**;**
…TRUE TEXT…
%END**;**
%ELSE%DO**;**
…FALSE TEXT…
%END**;**
```

- 循环控制

与 SAS 代码的循环控制类似，SAS 宏的循环控制有如下几种形式：

1) 确定性循环 DO-TO-BY：具有固定循环次数或步长时使用，类似于传统编程中的 FOR 循环,其中控制循环起点的 START 、终点的 END 和步长 STEP 可以是宏常量、宏变量或者任何能够展开为整数的宏表达式，%BY 语句是可选，默认步长为 1 .

```
%DO<MACRO-VAR> = <START> %TO<END> [%BYSTEP];
…LOOP TEXT…
%END;
```



2) 不确定循环 DO-WHILE：在进入循环体前进行判断，为真则执行循环体，为假则离开循环。

```
%DO%WHILE<MACRO EXPRESSION>;
…LOOP TEXT…
%END;
```

3) 不确定循环 DO-UNTIL：执行循环体后进行判断，为真则退出循环体，为假则继续循环；这种循环方式至少会执行循环体一次。

```
%DO%UNTIL<MACRO EXPRESSION>;
…LOOP TEXT…
%END;
```

为综合演示 SAS 宏的逻辑控制，下面我们完全用 SAS 宏来实现前面黄金分割数的例子：

```
%macroFbnc;
%localy1 y2;
%don=1%to20;
%if%eval(&n=1or &n=2) %then%lety=1;
%else%lety= %eval( &y1 + &y2 );
%lety2=&y1; %lety1=&y;
%putn=&n y=&y; /打印到SAS日志/
%end;
%mend;
%Fbnc; /调用宏函数Fbnc/
系统输出为：
n=1 y=1
n=2 y=1
n=3 y=2
n=4 y=3
…
n=20 y=6765
```



结语

SAS 宏为 SAS 编程语言提供了语言之上的超级语言，可以让 SAS 程序自身在必要的时候改变自己，呈现出千变万化的可能。但我们也不能忘记，SAS 宏展开生成的任何 SAS 代码依然要遵守 SAS 语言的基本规范。编写 SAS 程序时脑海里要很清楚 SAS 宏代码、SAS 代码在编译前后的差别，避免自己在 SAS 语言元素太过丰富的丛林里迷失而失去对程序的控制。由于 SAS 宏太过强大和容易令人困惑，我将 SAS 宏分两部分进行讲述，后一部分将探讨一些高级话题。

小任务

请用所学的函数封装技巧分别实现阶乘功能；比如5!就是5 x 4 x 3 x 2 x 1，即 facterial(5)= 120